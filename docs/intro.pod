
=head1 Deck: The Quick-and-Dirty Guided Tour

The problem with programming languages is that you can't just throw up
a few screenshots on the website to show off how cool it is.  You need
to show code and then point out how cool it is, preferably in a brief
and witty way.

Oh well.

Instead, I give you the Fibinacci Examples:

=head2 The Fibonacci Sequence

You all know what that is, right?  So I don't need to explain that
it's a sequence of numbers:

	1 1 2 3 5 8 13 21 34 55 89 144 233 ...

where each number is the sum of the two previous numbers.  Which is
good because explaining all of that would take forever!


=head2 Basic Itterative Implementation

It's pretty simple to code a procedure that prints out some of the
Fibonacci series:

    proc printFibs [count] {
    	var first = 1
		var second = 1
    
    	for n in (1 .. count) {
    		say "$first "
    
    		var ns = (first + second)
    		first = second
    		second = ns
    	}
    	puts
    }

Obvious things:

=over

=item * C<proc> defines the procedure, C<printFibs> is the name of the
procedure, C<[count]> is the argument list and the rest is the
procedure body.

=item * C<var> declares a variable.

=item * C<say> prints its argument(s).  C<puts> does to but it adds a
newline.

=item * C<for> itterates over a range of numbers.

=item * Deck provides Perl/Tcl/shell-style variable interpolation in
strings.  (E.g. "$first " contains the value of variable C<first>.)

=back

Less-obvious things:

=over

=item * If you think of a program "line" as not ending until all the
brackets are closed, then the entire procedure can be thought of as
one line.

=item * The text between braces (C<{> and C<}>) is subdivided into
"lines" as above, making a single "line" able to contain multiple
other "lines".

=item * Therefore, each Deck statement is a single "line".
Furthermore, the first item in the "line" is the procedure to call and
the remaining items are the arguments to pass to it.

=item * Expressions bracketted by round parentheses (C<(> and C<)>)
are parsed as infix expressions (e.g. (2 + 3) instead of [+ 2 3]).

=item * Assignments (e.g. C<first = second>) have imaginary round
brackets around them.  So does the expression after C<var>.

=item * Notice the round brackets around the third argument top
C<for>: C<(1 .. count)>.  This is an infix expression.  In fact, C<..>
creates an object (type C<Interval>) which mimics a list containing
the range of integers between the left-hand-side and right-hand-side
arguments.  From this, it becomes clear that what C<for> actually does
is evaluate its body for each element of a list-like object it
receives.

=back

=head3 Special Forms, absence of.

Firstly, you'll notice that a lot of statements take arguments that
look like they should be evaluated but aren't: the word C<printFibs>
after C<proc>, the C<n> after C<for>, the variable names, etc.  In
most Lisp dialects, the language has a fixed number of I<Special
Forms>--things that look like functions but have their arguments
parsed differently.

Deck has one special form, the quote symbol: C<:>.  Things prefixed by
a colon are not evaluated.  As you can see, there is no quoting in the
example above.  (Actually, that's not true: C<{> is an implicit
quote.  But I'll get to that later.)

Instead C<for>, C<var> and C<proc> are all macros.  In Deck, a macro
is simply a function called by the compiler to modify the current
expression in some way--a compiler plug-in, as it were.  Most of
Deck's built-in functionality is actually implemented using macros.


=head2 Recursive Implementation

Subject to the Laws of Computer Science, I am required to show you a
recursive function, so here it is:

	proc fib {index} {
		(index <= 2) && [return 1]
		return ([fib (index - 1)] + [fib (index - 2)])	
	}

Of course, it also needs this function:

    proc printFibs {count} {
    	for n in (1 .. count) {
    		say [fib n] " "
    	}
    	puts
    }

Needless to say, it is 1) minimal and elegant and 2) pig slow because
for each new Fibonacci number, it needs to recalculate the entire
series.  However, from this code, I can point out a few more things:

=over

=item * Square brackets (C<[> and C<]>) delimit standard Deck
expressions (i.e. prefix expressions) such as C<[fib n]>.

=item * Like assignments, expressions made up of C<&&> and C<||> also
have implicit round brackets.  This lets you do Perl-style flow
control with short-circuited boolean operators, as I do in the first
line of C<fib>.

=item * C<proc> lets you wrap the argument list in braces (C<{> and
C<}>) instead of square brackets.  This is pure syntactic sugar by
C<proc> in oreder to make Tcl programmers a bit more comfortable.

=back


=head2 Implementation by Closure

Now, we start getting to the contrived examples:

    proc fibFn {} {
    	var {first = 1; second = 1}

    	return {} => {
    		var newSecond = first + second
    		var result = first

    		first = second
    		second = newSecond

    		next result
    	}
    }

    proc printFibs {count} {
    	var ff = [fibFn]

    	for n in (1 .. count) {
    		say [ff] " "
    	}
    	puts
    }

As you know Bob, a closure (aka "sub") is an anonymous function that
has access to the scope in which it was created.  The Deck operator
C<=E<gt>> creates a closure: the left operand is the argument list and
the right is the function body.

So proc C<fibFn> defines and initializes the variables C<first> and
C<second>, then creates and returns a closure.  C<printFibs> takes the
closure (referenced by variable C<ff>) and calls it repeatedly to
generate each new number in the Fibonacci sequence.  The current and
next Fibonacci numbers are stored in C<first> and C<second> in fibFn
which, having exited, are now only visible to the closure.

Things to note:

=over

=item * The C<E<gt>> expression in C<fibFn> doesn't have round
brackets around it, even though it should.  That's because the parser
automatically surrounds a C<=E>gt>> expression with them in an infix
expression.  This is more syntactic sugar.

=item * The C<return> statement has been renamed C<next> inside a
closure.  This is so that you can return from a closure without
returning from the function that created it.

=item * Closures are awesome!

=back


=head2 A Digression: C<return> and C<next>

While we're talking about C<return> (and C<next>) I should explain
just how frickin' cool they are.

In most languages, C<return> is a control structure.  Using it makes
the compiler (or interpreter) exit the current function.  In Deck,
C<return> is a callable object, a I<continuation>.  Calling it like a
function returns the function that called it I<and every function it's
currently calling>.  For example:

    proc i2 {ret} {
    	ret 42
    	puts "i2 done"
    }

    proc i1 {ret} {
    	i2 ret
    	puts "i1 done."
    }

    proc i0 {} {
    	puts "starting i0"
    	i1 return
    	puts "done i0"
    }

    proc outer {} {
    	puts "calling i0"
    	i0
    	puts "done i0"
    }

    outer

when run, produces this output:

    calling i0
    starting i0
    done i0

C<i0> passes its return as an argument to C<i1> which calls C<i2> with
it.  When C<i2> finally calls the continuation, the call sequence is
completely unwound and C<i0> returns.  If C<ret> had been given an
argument, it would have been used as the return value.

(In closures, C<return> has been renamed to C<next> but is otherwise
the same.)

Since unexpectedly returning from a procedure can leave loose ends, a
proc (or method or closure) may take a I<final block>.  The final
block another block of code to execute after the body of a sub, proc
or method has finished.  It is guaranteed to execute, no matter how
the procedure returns.  This lets you do stuff like this:

	proc readDataFile {fileName} {
		var fh = [openDataFile filename]
		[readHeader fh] || [return false]
		[readBody fh] || [return false]
		return true
	} {
		closeDataFile fh
	}

Because the second block always returns, C<closeDataFile> is always
called, even if C<readDataFile> returned when C<readHeader> called a
continuation stored in a global variable or some equally idiotic
thing.


=head2 Digression #2: MProcs

As mentioned above, Deck has macros.  They're simple and ugly and God
help you if you need to use them.

Deck also has a nicer lightweight macro called an C<mproc>.  An
C<mproc> is just a procedure whose calls get modified in various
simple ways by an automatically-generated macro.  They can be used for
a number of things but the most common use (so far) is to make fake
control structures.  For example, this:

    mproc repeat {
    	count
    	sub 1 pr
    } {
    	for i in (0 .. count - 1) {pr i}
	}
	
can be called like this:

	repeat 5 {puts "I like pie!"}

The special declaration of argument C<pr> turns its second argument
into a sub.  Since it's a sub, it has access to the C<return> of the
C<proc> in which it was created, so you can still return from inside
it.


=head2 The Infinite Stream Implementation

Okay, back to Fibonacci.

Infinite streams are a cool idea I stole from I<Higher Order Perl>
(who stole it from the Lisp community).  Each stream is a linked list
whose last element is computed lazily.  In other words, the last
element is a procedure of some kind that computes the value and
follows it with a procedure that does the same for the following value.

Since this is a Lisp thing, it requires linked lists.  Deck lists are
not linked lists, so I first need to implement linked lists using a
class:

    class Node {
    	public head tail

    	method _init {h t} {
    		head = h
    		tail = t
    	}

    	method tail_get {} {
    		(tail.isCallable) && (tail = [tail])
    		return tail
    	}
    }

This is pretty straightforward.  C<head> and C<tail> are public, which
means they can be accessed by the C<.> operator.  The method
C<tail_get> overrides reads of C<tail>.  In this case, we use it to
force the evaluation of C<tail> if C<tail> is a closure.  This comes
in handy when we actually create the stream:

XXXXXXXXXXXXXXXXXXXXXXX











=head2 The Fake List Implementation

Deck, you may have read, is an object-oriented language.  In
particular, members of the C<List> type which gets used for everything
are also objects.  Due to the magic of polymorphism, this means that
it's easy to create a class which mimics the basic functionality of a
list.  We can (ab)use this to create a fake list which appears to be
full of Fibonacci numbers:

    class FibonacciList {
    	var first second
    	var prevCallIndex
    	readable size

    	method isIndexable_get {} {return true}

    	method _init {sz} {
    		size = sz
    		self->_reset
    	}

    	method _reset {} {
    		first = 1
    		second = 1
    		prevCallIndex = 0
    	}

    	method at {index} {
    		self->_update index
    		return first
    	}

    	method _update {reqIndex} {
    		(reqIndex >= prevCallIndex) || [self->_reset]

    		repeat (reqIndex - prevCallIndex) {
    			var ns = first + second
    			first = second
    			second = ns
    		}

    		prevCallIndex = reqIndex
    	}
    }


    proc printFibs {count} {
    	var fl = [FibonacciList->new count]

    	for n in fl {say n " "}
    	puts
    }






