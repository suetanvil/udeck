
=head1 Deck: The Quick-and-Dirty Guided Tour

The problem with programming languages is that you can't just throw up
a few screenshots on the website to show off how cool it is.  You need
to show code and then point out how cool it is, preferably in a brief
and witty way.

Oh well.

Instead, I give you the Fibinacci Examples:

=head2 The Fibonacci Sequence

You all know what that is, right?  So I don't need to explain that
it's a sequence of numbers:

	1 1 2 3 5 8 13 21 34 55 89 144 233 ...

where each number is the sum of the two previous numbers.  Which is
good because explaining all of that would take forever!


=head2 Basic Itterative Implementation

It's pretty simple to code a procedure that prints out some of the
Fibonacci series:

    proc printFibs [count] {
    	var first = 1
		var second = 1
    
    	for n in (1 .. count) {
    		say "$first "
    
    		var ns = (first + second)
    		first = second
    		second = ns
    	}
    	puts
    }

Obvious things:

=over

=item * C<proc> defines the procedure, C<printFibs> is the name of the
procedure, C<[count]> is the argument list and the rest is the
procedure body.

=item * C<var> declares a variable.

=item * C<say> prints its argument(s).  C<puts> does to but it adds a
newline.

=item * C<for> itterates over a range of numbers.

=item * Deck provides Perl/Tcl/shell-style variable interpolation in
strings.  (E.g. "$first " contains the value of variable C<first>.)

=back

Less-obvious things:

=over

=item * If you think of a program "line" as not ending until all the
brackets are closed, then the entire procedure can be thought of as
one line.

=item * The text between braces (C<{> and C<}>) is subdivided into
"lines" as above, making a single "line" able to contain multiple
other "lines".

=item * Therefore, each Deck statement is a single "line".
Furthermore, the first item in the "line" is the procedure to call and
the remaining items are the arguments to pass to it.

=item * Expressions bracketted by round parentheses (C<(> and C<)>)
are parsed as infix expressions (e.g. (2 + 3) instead of [+ 2 3]).

=item * Assignments (e.g. C<first = second>) have imaginary round
brackets around them.  So does the expression after C<var>.

=item * Notice the round brackets around the third argument top
C<for>: C<(1 .. count)>.  This is an infix expression.  In fact, C<..>
creates an object (type C<Interval>) which mimics a list containing
the range of integers between the left-hand-side and right-hand-side
arguments.  From this, it becomes clear that what C<for> actually does
is evaluate its body for each element of a list-like object it
receives.

=back

=head3 Special Forms, absence of.

Firstly, you'll notice that a lot of statements take arguments that
look like they should be evaluated but aren't: the word C<printFibs>
after C<proc>, the C<n> after C<for>, the variable names, etc.  In
most Lisp dialects, the language has a fixed number of I<Special
Forms>--things that look like functions but have their arguments
parsed differently.

Deck has one special form, the quote symbol: C<:>.  Things prefixed by
a colon are not evaluated.  As you can see, there is no quoting in the
example above.  (Actually, that's not true: C<{> is an implicit
quote.  But I'll get to that later.)

Instead C<for>, C<var> and C<proc> are all macros.  In Deck, a macro
is simply a function called by the compiler to modify the current
expression in some way--a compiler plug-in, as it were.  Most of
Deck's built-in functionality is actually implemented using macros.


=head2 Recursive Implementation

Subject to the Laws of Computer Science, I am required to show you a
recursive function, so here it is:

	proc fib {index} {
		(index <= 2) && [return 1]
		return ([fib (index - 1)] + [fib (index - 2)])	
	}

Of course, it also needs this function:

    proc printFibs {count} {
    	for n in (1 .. count) {
    		say [fib n] " "
    	}
    	puts
    }

Needless to say, it is 1) minimal and elegant and 2) pig slow because
for each new Fibonacci number, it needs to recalculate the entire
series.  However, from this code, I can point out a few more things:

=over

=item * Square brackets (C<[> and C<]>) delimit standard Deck
expressions (i.e. prefix expressions) such as C<[fib n]>.

=item * Like assignments, expressions made up of C<&&> and C<||> also
have implicit round brackets.  This lets you do Perl-style flow
control with short-circuited boolean operators, as I do in the first
line of C<fib>.

=item * C<proc> lets you wrap the argument list in braces (C<{> and
C<}>) instead of square brackets.  This is pure syntactic sugar by
C<proc> in oreder to make Tcl programmers a bit more comfortable.

=back


=head2 Implementation by Closure

Now, we start getting to the contrived examples:

    proc fibFn {} {
    	var {first = 1; second = 1}

    	return {} => {
    		var newSecond = first + second
    		var result = first

    		first = second
    		second = newSecond

    		next result
    	}
    }

    proc printFibs {count} {
    	var ff = [fibFn]

    	for n in (1 .. count) {
    		say [ff] " "
    	}
    	puts
    }

As you know Bob, a closure (aka "sub") is an anonymous function that
has access to the scope in which it was created.  The Deck operator
C<=E<gt>> creates a closure: the left operand is the argument list and
the right is the function body.

So proc C<fibFn> defines and initializes the variables C<first> and
C<second>, then creates and returns a closure.  C<printFibs> takes the
closure (referenced by variable C<ff>) and calls it repeatedly to
generate each new number in the Fibonacci sequence.  The current and
next Fibonacci numbers are stored in C<first> and C<second> in fibFn
which, having exited, are now only visible to the closure.

Things to note:

=over

=item * The C<E<gt>> expression in C<fibFn> doesn't have round
brackets around it, even though it should.  That's because the parser
automatically surrounds a C<=E>gt>> expression with them in an infix
expression.  This is more syntactic sugar.

=item * The C<return> statement has been renamed C<next> inside a
closure.  This is so that you can return from a closure without
returning from the function that created it.

=item * Closures are awesome!

=back


=head2 A Digression: C<return> and C<next>

While we're talking about C<return> (and C<next>) I should explain
just how frickin' cool they are.

In most languages, C<return> is a control structure.  Using it makes
the compiler (or interpreter) exit the current function.  In Deck,
C<return> is a callable object, a I<continuation>.  Calling it like a
function returns the function that called it I<and every function it's
currently calling>.  For example:

    proc i2 {ret} {
    	ret 42
    	puts "i2 done"
    }

    proc i1 {ret} {
    	i2 ret
    	puts "i1 done."
    }

    proc i0 {} {
    	puts "starting i0"
    	i1 return
    	puts "done i0"
    }

    proc outer {} {
    	puts "calling i0"
    	i0
    	puts "done i0"
    }

    outer

when run, produces this output:

    calling i0
    starting i0
    done i0

C<i0> passes its return as an argument to C<i1> which calls C<i2> with
it.  When C<i2> finally calls the continuation, the call sequence is
completely unwound and C<i0> returns.  If C<ret> had been given an
argument, it would have been used as the return value.

(In closures, C<return> has been renamed to C<next> but is otherwise
the same.)

Since unexpectedly returning from a procedure can leave loose ends, a
proc (or method or closure) may take a I<final block>.  The final
block another block of code to execute after the body of a sub, proc
or method has finished.  It is guaranteed to execute, no matter how
the procedure returns.  This lets you do stuff like this:

	proc readDataFile {fileName} {
		var fh = [openDataFile filename]
		[readHeader fh] || [return false]
		[readBody fh] || [return false]
		return true
	} {
		closeDataFile fh
	}

Because the second block always executes, C<closeDataFile> is always
called, even if C<readDataFile> returned when C<readHeader> called a
continuation stored in a global variable or some equally idiotic
thing.


=head2 Digression #2: MProcs

As mentioned above, Deck has macros.  They're simple and ugly and God
help you if you need to use them.

Deck also has a nicer lightweight macro called an C<mproc>.  An
C<mproc> is just a procedure whose calls get modified in various
simple ways by an automatically-generated macro.  They can be used for
a number of things but the most common use (so far) is to make fake
control structures.  For example, this:

    mproc repeat {
    	count
    	sub 1 pr
    } {
    	for i in (0 .. count - 1) {pr i}
	}
	
can be called like this:

	repeat 5 {puts "I like pie!"}

The special declaration of argument C<pr> turns its second argument
into a sub.  Since it's a sub, it has access to the C<return> of the
C<proc> in which it was created, so you can still return from inside
it.


=head2 The Infinite Stream Implementation

Okay, back to Fibonacci.

The third implementation uses an infinite stream.  This is an
infinitely-long linked list which fakes infinity by computing the n'th
element just before you need it.  We do this by putting a procedure at
the end of the list and evaluating it when we get there.  The
procedure computes a new node containing the next value and another
procedure and this gets attached to the end.

Since Deck lists are not linked lists the way they are in
$FAVOURITE_LISP_DIALECT, I first need to implement linked lists using
a class:

    class Node {
    	public head tail

    	method _init {h t} {
    		head = h
    		tail = t
    	}
    }

This is pretty straightforward:

=over

=item C<head> and C<tail> are instance variables (aka object fields).
      The C<public> declaration means (obviously) that external code
      can read and write the value.

=item C<_init_> is called when an instance of C<Node> is created to
      initialize it.

=back

This is a "dumb" data structure.  It holds information but any
processing is done by external code, just like a C struct.  Since we
need to process C<tail>, we need a function to evaluate it:

    proc getTail {node} {
    	if (node.tail.isCallable) {
    		node.tail = [node.tail]
    	}

    	return node.tail
    }

This function returns the C<tail> field of C<Node> instance
C<node>.  If C<node> is callable (i.e. a procedure), it first calls it
and replaces the value of C<node> with the result.  (It also breaks
if the list contains real callable values, but we're not going to
worry about that now.)

The list gets set up by the function C<fib>:

    proc fibs {v1 v2} {
	    return [new Node v2 {}=>{fibs v2 (v1 + v2)} ]
    }

So as you can see, the (current) last item in the list is a closure
which returns a new C<Node> containing the Fibonacci value in
its C<head> and a new closure in C<tail>.

The C<printFibs> procedure looks like this:

    proc printFibs {count} {
    	var stream = [fibs 0 1]
    	repeat [str2num (Sys::Argv@0)] {
    		say stream.head " "
    		stream = [getTail stream]
    	}
    	puts
    }

As you can see, it uses C<fibs> to create the first node, then calls
C<getTail> on the stream to generate the next node.

Some more details:

=over

=item The C<.> operator is used to access the (public) fields of
      C<Node>.  It can be on either side of an assignment.

=item C<.>, like C<=E<gt>> is treated specially by the parser.  The
      sequence C< left . right > is automatically surrounded by round
      brackets whenever it is seen in a prefix expression.

=back

Calling C<getTail> is pretty cumbersome.  Fortunately, Deck's object
system lets us fold that functionality into the C<Node> class.  The
new C<Node> looks like this:

    class Node {
    	readable head
		var tail

    	method _init {h t} {
    		head = h
    		tail = t
    	}

    	method tail_get {} {
    		(tail.isCallable) && (tail = [tail])
    		return tail
    	}
    }

There are three changes:

=over

=item C<head> is now C<readable>, which means it can't be modified by
      external code.  This change is not strictly necessary (and we
      B<could> have made it C<readonly> in the previous example) but
      it makes for better code overall.

=item C<tail> is now declared private with the C<var> word.

=item Method C<tail_get> has been added.  This is what gets called
      when external code tries to read C<tail>.  It contains
      the functionality that used to be in C<getTail> so now, just
      accessing the C<tail> field does the right thing.

=back

And here's the (slightly) modified C<printFibs>:

    proc printFibs {count} {
    	var stream = [fibs 0 1]
    	repeat [str2num (Sys::Argv@0)] {
    		say stream.head " "
    		stream = stream.tail
    	}
    	puts
    }

This looks a lot cleaner.

Here are a couple of other things you should know about object
attributes:

=over

=item In addition to C<var>, C<public> and C<readable>, fields can be
      declared C<writable>.  This makes then settable but not
      readable.

=item It is also possible to override writing to a field by defining a
      method which takes one argument and has the same name as the
      field with C<_set> appended.  E.g. for field C<head>, it would
      be named C<head_set>.

=item So far, it looks like I'm implying that the C<_get> and C<_set>
      methods are being called by a field access.  It's actually
      backwards.  All class fields are private and declaring a field
      C<public> (or C<readable> or C<writeable>) causes the compiler
      to generate trivial getters and setters.

=item The compiler will never generate a getter or setter if you've
      already written one, so if you've declared a field public but
      written your own getter, it is your getter that will be called.

=item You may write a getter or setter for a non-existent variable.
      That is, the public interface does not need to correspond to the
      internal structure of the class.

=back

(Attribution: I stole the idea of infinite streams from Mark Jason
Dominus's book I<Higher Order Perl> who stole it from somewhere in
Lisp Land.)



=head2 Digression #3: More on Objects

The examples in this document aren't particularly good at highlighting
all the interesting corners of Deck's object system, so I'm taking a
few paragraphs to drop knowledge on you.

In Deck, everything is an object.  This includes classes, which are
all instances of the class C<Class>.  This includes C<Class> itself
which is its own class.  Classes can be passed around and queried but
all classes have the same interface.  This means that there's no such
thing as a class (aka "static") method or field.  Instead, you should
use packages.  (See the reference manual for a long, tedious
description of those.)

Instance variables in classes are only visible to the methods defined
in that class, B<not> in any subclass.  Their scope is the equivalent
of C<private> in C++.  This doesn't work:

	class Inner {
		public foo
		method _init {x} {
			foo = x
		}
	}

	class Outer Inner {
		method bar {m} {
			puts m foo	# ERROR: foo not visible
		}
	}

But this will work:

	class Outer Inner {
		method bar {m} {
			puts m self.foo
		}
	}

This is because C<self.foo> invokes the access method defined by
C<public>.  (C<self> is a reference to the current object.)

(Note that there's a bug in the current implementation of Deck that
prevents you from defining an instance variable with the same name as
an instance variable in a parent class even though they are
unambiguous.)

Methods are normally invoked using the C<-E<gt>> operator:

	var x = [new Outer]
	x->bar "Value: "

(C<-E<gt>> is syntactically magical just like C<.> and C<=E<gt>>.)

The semantics of C<-E<gt>> are interesting by themselves.  The result
of C<x-E<gt>bar> is a callable object called a C<MethodCall>.  This
encapsulates the result of the method search of C<x> for C<bar>.  When
called like a procedure, it calls the method found (usually C<bar>)
with C<self> set to C<x> and with whatever arguments it was given.
The C<MethodCall> can thus be stored or passed around:

	var bar = [new Outer]->bar

	...

	bar "Value: "

If the method lookup fails (i.e. there is no method with that name in
the object's class heirarchy), the lookup calls the special method
C<doesNotUnderstand> instead.  Default behaviour for
C<doesNotUnderstand> is to exit with a backtrace but individual
classes may override this behaviour.








=head2 The Fake List Implementation

Deck, you may have read, is an object-oriented language.  In
particular, members of the C<List> type which gets used for everything
are also objects.  Due to the magic of polymorphism, this means that
it's easy to create a class which mimics the basic functionality of a
list.  We can (ab)use this to create a fake list which appears to be
full of Fibonacci numbers:

    class FibonacciList {
    	var first second
    	var prevCallIndex
    	readable size

    	method isIndexable_get {} {return true}

    	method _init {sz} {
    		size = sz
    		self->_reset
    	}

    	method _reset {} {
    		first = 1
    		second = 1
    		prevCallIndex = 0
    	}

    	method at {index} {
    		self->_update index
    		return first
    	}

    	method _update {reqIndex} {
    		(reqIndex >= prevCallIndex) || [self->_reset]

    		repeat (reqIndex - prevCallIndex) {
    			var ns = first + second
    			first = second
    			second = ns
    		}

    		prevCallIndex = reqIndex
    	}
    }


    proc printFibs {count} {
    	var fl = [FibonacciList->new count]

    	for n in fl {say n " "}
    	puts
    }






