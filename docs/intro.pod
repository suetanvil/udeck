
=head1 Deck: The Quick-and-Dirty Guided Tour

The problem with programming languages is that you can't just throw up
a few screenshots on the website to show off how cool it is.  You need
to show code and then point out how cool it is, preferably in a brief
and witty way.

Oh well.

Instead, I give you the Fibinacci Examples:

=head2 The Fibonacci Sequence

You all know what that is, right?  So I don't need to explain that
it's a sequence of numbers:

	1 1 2 3 5 8 13 21 34 55 89 144 233 ...

where each number is the sum of the two previous numbers.  Which is
good because explaining all of that would take forever!


=head2 Basic Itterative Implementation

It's pretty simple to code a procedure that prints out some of the
Fibonacci series:

    proc printFibs [count] {
    	var first = 1
		var second = 1
    
    	for n in (1 .. count) {
    		say "$first "
    
    		var ns = (first + second)
    		first = second
    		second = ns
    	}
    	puts
    }

Obvious things:

=over

=item * C<proc> defines the procedure, C<printFibs> is the name of the
procedure, C<[count]> is the argument list and the rest is the
procedure body.

=item * C<var> declares a variable.

=item * C<say> prints its argument(s).  C<puts> does to but it adds a
newline.

=item * C<for> itterates over a range of numbers.

=item * Deck provides Perl/Tcl/shell-style variable interpolation in
strings.  (E.g. "$first " contains the value of variable C<first>.)

=back

Less-obvious things:

=over

=item * If you think of a program "line" as not ending until all the
brackets are closed, then the entire procedure can be thought of as
one line.

=item * The text between braces (C<{> and C<}>) is subdivided into
"lines" as above, making a single "line" able to contain multiple
other "lines".

=item * Therefore, each Deck statement is a single "line".
Furthermore, the first item in the "line" is the procedure to call and
the remaining items are the arguments to pass to it.

=item * Expressions bracketted by round parentheses (C<(> and C<)>)
are parsed as infix expressions (e.g. (2 + 3) instead of [+ 2 3]).

=item * Assignments (e.g. C<first = second>) have imaginary round
brackets around them.  So does the expression after C<var>.

=item * Notice the round brackets around the third argument top
C<for>: C<(1 .. count)>.  This is an infix expression.  In fact, C<..>
creates an object (type C<Interval>) which mimics a list containing
the range of integers between the left-hand-side and right-hand-side
arguments.  From this, it becomes clear that what C<for> actually does
is evaluate its body for each element of a list-like object it
receives.

=back

=head3 Special Forms, absence of.

Firstly, you'll notice that a lot of statements take arguments that
look like they should be evaluated but aren't: the word C<printFibs>
after C<proc>, the C<n> after C<for>, the variable names, etc.  In
most Lisp dialects, the language has a fixed number of I<Special
Forms>--things that look like functions but have their arguments
parsed differently.

Deck has one special form, the quote symbol: C<:>.  Things prefixed by
a colon are not evaluated.  As you can see, there is no quoting in the
example above.  (Actually, that's not true: C<{> is an implicit
quote.  But I'll get to that later.)

Instead C<for>, C<var> and C<proc> are all macros.  In Deck, a macro
is simply a function called by the compiler to modify the current
expression in some way--a compiler plug-in, as it were.  Most of
Deck's built-in functionality is actually implemented using macros.


=head2 Recursive Implementation

Subject to the Laws of Computer Science, I am required to show you a
recursive function, so here it is:

	proc fib {index} {
		(index <= 2) && [return 1]
		return ([fib (index - 1)] + [fib (index - 2)])	
	}

Of course, it also needs this function:

    proc printFibs {count} {
    	for n in (1 .. count) {
    		say [fib n] " "
    	}
    	puts
    }

Needless to say, it is 1) minimal and elegant and 2) pig slow because
for each new Fibonacci number, it needs to recalculate the entire
series.  However, from this code, I can point out a few more things:

=over

=item * Square brackets (C<[> and C<]>) delimit standard Deck
expressions (i.e. prefix expressions) such as C<[fib n]>.

=item * Like assignments, expressions made up of C<&&> and C<||> also
have implicit round brackets.  This lets you do Perl-style flow
control with short-circuited boolean operators, as I do in the first
line of C<fib>.

=item * C<proc> lets you wrap the argument list in braces (C<{> and
C<}>) instead of square brackets.  This is pure syntactic sugar by
C<proc> in oreder to make Tcl programmers a bit more comfortable.

=back


=head2 Implementation by Closure

Now, we start getting to the contrived examples:

    proc fibFn {} {
    	var {first = 1; second = 1}

    	return {} => {
    		var newSecond = first + second
    		var result = first

    		first = second
    		second = newSecond

    		next result
    	}
    }

    proc printFibs {count} {
    	var ff = [fibFn]

    	for n in (1 .. count) {
    		say [ff] " "
    	}
    	puts
    }

As you know Bob, a closure is an anonymous function that has access to
the scope in which it was created.  The Deck operator C<=E<gt>>
creates a closure: the left operand is the argument list and the right
is the function body.


