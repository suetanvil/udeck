
=head1 Deck: The Quick-and-Dirty Guided Tour

The problem with programming languages is that you can't just throw up
a few screenshots on the website to show off how cool it is.  You need
to show code and then point out how cool it is, preferably in a brief
and witty way.

Oh well.

Instead, I give you the Fibinacci Examples:

=head2 The Fibonacci Sequence

You all know what that is, right?  So I don't need to explain that
it's a sequence of numbers:

	1 1 2 3 5 8 13 21 34 55 89 144 233 ...

where each number is the sum of the two previous numbers.  Which is
good because explaining all of that would take forever!


=head2 Basic Itterative Implementation

It's pretty simple to code a procedure that prints out some of the
Fibonacci series:

    proc printFibs [count] {
    	var first = 1
		var second = 1
    
    	for n in (1 .. count) {
    		say "$first "
    
    		var ns = (first + second)
    		first = second
    		second = ns
    	}
    	puts
    }

Obvious things:

=over

=item * C<proc> defines the procedure, C<printFibs> is the name of the
procedure, C<[count]> is the argument list and the rest is the
procedure body.

=item * C<var> declares a variable.

=item * C<say> prints its argument(s).  C<puts> does to but it adds a
newline.

=item * C<for> itterates over a range of numbers.

=item * Deck provides Perl/Tcl/shell-style variable interpolation in
strings.  (E.g. "$first " contains the value of variable C<first>.)

=back

Less-obvious things:

=over

=item * If you think of a program "line" as not ending until all the
brackets are closed, then the entire procedure can be thought of as
one line.

=item * The text between braces (C<{> and C<}>) is subdivided into
"lines" as above, making a single "line" able to contain multiple
other "lines".

=item * Therefore, each Deck statement is a single "line".
Furthermore, the first item in the "line" is the procedure to call and
the remaining items are the arguments to pass to it.

=item * Expressions bracketted by round parentheses (C<(> and C<)>)
are parsed as infix expressions (e.g. (2 + 3) instead of [+ 2 3]).

=item * Assignments (e.g. C<first = second>) have imaginary round
brackets around them.  So does the expression after C<var>.

=item * Notice the round brackets around the third argument top
C<for>: C<(1 .. count)>.  This is an infix expression.  In fact, C<..>
creates an object (type C<Interval>) which mimics a list containing
the range of integers between the left-hand-side and right-hand-side
arguments.  From this, it becomes clear that what C<for> actually does
is evaluate its body for each element of a list-like object it
receives.

=back

=head3 Special Forms, absence of.

Firstly, you'll notice that a lot of statements take arguments that
look like they should be evaluated but aren't: the word C<printFibs>
after C<proc>, the C<n> after C<for>, the variable names, etc.  In
most Lisp dialects, the language has a fixed number of I<Special
Forms>--things that look like functions but have their arguments
parsed differently.

Deck has one special form, the quote symbol: C<:>.  Things prefixed by
a colon are not evaluated.  As you can see, there is no quoting in the
example above.  (Actually, that's not true: C<{> is an implicit
quote.  But I'll get to that later.)

Instead C<for>, C<var> and C<proc> are all macros.  In Deck, a macro
is simply a function called by the compiler to modify the current
expression in some way--a compiler plug-in, as it were.  Most of
Deck's built-in functionality is actually implemented using macros.


=head2 Recursive Implementation

Subject to the Laws of Computer Science, I am required to show you a
recursive function, so here it is:

	proc fib {index} {
		(index <= 2) && [return 1]
		return ([fib (index - 1)] + [fib (index - 2)])	
	}

Of course, it also needs this function:

    proc printFibs {count} {
    	for n in (1 .. count) {
    		say [fib n] " "
    	}
    	puts
    }

Needless to say, it is 1) minimal and elegant and 2) pig slow because
for each new Fibonacci number, it needs to recalculate the entire
series.  However, from this code, I can point out a few more things:

=over

=item * Square brackets (C<[> and C<]>) delimit standard Deck
expressions (i.e. prefix expressions) such as C<[fib n]>.

=item * Like assignments, expressions made up of C<&&> and C<||> also
have implicit round brackets.  This lets you do Perl-style flow
control with short-circuited boolean operators, as I do in the first
line of C<fib>.

=item * C<proc> lets you wrap the argument list in braces (C<{> and
C<}>) instead of square brackets.  This is pure syntactic sugar by
C<proc> in oreder to make Tcl programmers a bit more comfortable.

=back


=head2 Implementation by Closure

Now, we start getting to the contrived examples:

    proc fibFn {} {
    	var {first = 1; second = 1}

    	return {} => {
    		var newSecond = first + second
    		var result = first

    		first = second
    		second = newSecond

    		next result
    	}
    }

    proc printFibs {count} {
    	var ff = [fibFn]

    	for n in (1 .. count) {
    		say [ff] " "
    	}
    	puts
    }

As you know Bob, a closure (aka "sub") is an anonymous function that
has access to the scope in which it was created.  The Deck operator
C<=E<gt>> creates a closure: the left operand is the argument list and
the right is the function body.

So proc C<fibFn> defines and initializes the variables C<first> and
C<second>, then creates and returns a closure.  C<printFibs> takes the
closure (referenced by variable C<ff>) and calls it repeatedly to
generate each new number in the Fibonacci sequence.  The current and
next Fibonacci numbers are stored in C<first> and C<second> in fibFn
which, having exited, are now only visible to the closure.

Things to note:

=over

=item * The C<E<gt>> expression in C<fibFn> doesn't have round
brackets around it, even though it should.  That's because the parser
automatically surrounds a C<=E>gt>> expression with them in an infix
expression.  This is more syntactic sugar.

=item * The C<return> statement has been renamed C<next> inside a
closure.  This is so that you can return from a closure without
returning from the function that created it.

=item * Closures are awesome!

=back


=head2 A Digression: C<return> and C<next>

While we're talking about C<return> (and C<next>) I should explain
just how frickin' cool they are.

In most languages, C<return> is a control structure.  Using it makes
the compiler (or interpreter) exit the current function.  In Deck,
C<return> is a callable object, a I<continuation>.  Calling it like a
function returns the function that called it I<and every function it's
currently calling>.  For example:

    proc i2 {ret} {
    	ret 42
    	puts "i2 done"
    }

    proc i1 {ret} {
    	i2 ret
    	puts "i1 done."
    }

    proc i0 {} {
    	puts "starting i0"
    	i1 return
    	puts "done i0"
    }

    proc outer {} {
    	puts "calling i0"
    	i0
    	puts "done i0"
    }

    outer

when run, produces this output:

    calling i0
    starting i0
    done i0

C<i0> passes its return as an argument to C<i1> which calls C<i2> with
it.  When C<i2> finally calls the continuation, the call sequence is
completely unwound and C<i0> returns.  If C<ret> had been given an
argument, it would have been used as the return value.

(In closures, C<return> has been renamed to C<next> but is otherwise
the same.)

Since unexpectedly returning from a procedure can leave loose ends, a
proc (or method or closure) may take a I<final block>.  The final
block another block of code to execute after the body of a sub, proc
or method has finished.  It is guaranteed to execute, no matter how
the procedure returns.  This lets you do stuff like this:

	proc readDataFile {fileName} {
		var fh = [openDataFile filename]
		[readHeader fh] || [return false]
		[readBody fh] || [return false]
		return true
	} {
		closeDataFile fh
	}

Because the second block always returns, C<closeDataFile> is always
called, even if C<readDataFile> returned when C<readHeader> called a
continuation stored in a global variable or some equally idiotic
thing.


=head2 Digression #2: MProcs

As mentioned above, Deck has macros.  They're simple and ugly and God
help you if you need to use them.

Deck also has a nicer lightweight macro called an C<mproc>.  An
C<mproc> is just a procedure whose calls get modified in various
simple ways by an automatically-generated macro.  They can be used for
a number of things but the most common use (so far) is to make fake
control structures.  For example, this:

    mproc repeat {
    	count
    	sub 1 pr
    } {
    	for i in (0 .. count - 1) {pr i}
	}
	
can be called like this:

	repeat 5 {puts "I like pie!"}

The special declaration of argument C<pr> turns its second argument
into a sub.  Since it's a sub, it has access to the C<return> of the
C<proc> in which it was created, so you can still return from inside
it.


=head2 The Infinite Stream Implementation

Okay, back to Fibonacci.

The third implementation uses an infinite stream.  This is a linked
list whose last element is a procedure that computes the expected
value followed by another such procedure.  The result is an infinitely
long linked list whose elements are only computed the first time you
retrieve them.

Since Deck lists are not linked lists the way they are in
$FAVOURITE_LISP_DIALECT, I first need to implement linked lists using
a class:

	class SimpleNode {
		readable head tail

    	method _init {h t} {
    		head = h
    		tail = t
    	}
	}	

This is pretty straightforward:

=over

=item C<head> and C<tail> are instance variables (aka object fields).
      The C<readonly> declaration means (obviously) that external code
      can read but not write the value.   They could also have been
      declared C<public>, C<writeable> (i.e. write-only) or C<var>
      (i.e. private) if necessary.

=item The C<.> operator is used to read and write object fields
      (e.g. C<x = sn.head>).  Like C<=E<gt>>, the parser
      will automatically surround a C<.> expression with implicit
      round parentheses.

=item C<_init_> is called when an instance of C<SimpleNode> is created to
      initialize it.

=back




    class Node {
    	readable head
		var tail

    	method _init {h t} {
    		head = h
    		tail = t
    	}

    	method tail_get {} {
    		(tail.isCallable) && (tail = [tail])
    		return tail
    	}
    }

Deck classes are (generally) pretty straightforward:


=over


=item C<.> expressions are expanded into calls to methods whose names
      are the field name followed by C<_set> or C<_get> to read or
      write the field.  Declaring a field C<readable>, C<writeable> or
      C<public> creates those methods but you can also write them
      yourself (e.g. C<tail_get>)..

=item C<tail_get> returns the value of the field C<tail>.  However, it
      first forces the field's evaluation if it's a procedure and
      replaces C<tail> with the result.  In other words, it lets us
      delay computing the actual value of C<tail> until the first time
      it needs to be read.  (This doesn't work if the result of the
      call is itself callable but we can ignore that for this example.)

=back



The C<printFibs> function shows how it's used:

    proc printFibs {count} {
    	var stream = [fibs 0 1]
    	repeat [str2num (Sys::Argv@0)] {
    		say stream.head " "
    		stream = stream.tail
    	}
    	puts
    }

C<stream> gets initialized to the start of the list as computed by
function C<fibs> (which I'll get to below) which returns the first
C<Node>.  The C<tail> of C<stream> is the next node so by pointing
C<stream> to its own C<tail>, we just advance through the list.

In effect, C<stream> is an infinitely long linked list whose elements
are created just before they're needed.

All of the heavy lifting is done in the function C<fibs>.  It looks
like this:

    proc fibs {v1 v2} {
	    return [new Node v2 {}=>{fibs v2 (v1 + v2)} ]
    }

That's all.











=head2 The Fake List Implementation

Deck, you may have read, is an object-oriented language.  In
particular, members of the C<List> type which gets used for everything
are also objects.  Due to the magic of polymorphism, this means that
it's easy to create a class which mimics the basic functionality of a
list.  We can (ab)use this to create a fake list which appears to be
full of Fibonacci numbers:

    class FibonacciList {
    	var first second
    	var prevCallIndex
    	readable size

    	method isIndexable_get {} {return true}

    	method _init {sz} {
    		size = sz
    		self->_reset
    	}

    	method _reset {} {
    		first = 1
    		second = 1
    		prevCallIndex = 0
    	}

    	method at {index} {
    		self->_update index
    		return first
    	}

    	method _update {reqIndex} {
    		(reqIndex >= prevCallIndex) || [self->_reset]

    		repeat (reqIndex - prevCallIndex) {
    			var ns = first + second
    			first = second
    			second = ns
    		}

    		prevCallIndex = reqIndex
    	}
    }


    proc printFibs {count} {
    	var fl = [FibonacciList->new count]

    	for n in fl {say n " "}
    	puts
    }






