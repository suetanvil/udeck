
=head1 Deck Library Reference

This is the reference manual for the Deck System Library.  The System
Library currently consists of all built-in objects (specifically,
procedures, macros, mprocs and classes) defined by the Deck
interpreter or in the module C<Lang.dk>.  It does B<not> document the
Deck language itself.  For that, see the Reference Manual.

It also does not (currently) document packages or global objects but
this is a shortcoming that will eventually be fixed.  Currently, there
is only one external package: C<Lang>, defined in the file
C<Lang.dk> which provides core functionality for Deck.

The manual itself is generated by the utility C<print_docstrings.dk>
from the docstrings of the various objects being documented.  There is
nothing new here that can't be found by reading the source code.
However, this manual puts it all in one place.

Names beginning with C<_::> (i.e. belonging to the C<_> namespace) are
internal to the system.  B<You should never use them.>  They are
documented here to satisfy any curiousity you might have and because
you may occasionally run into system-generated code that uses them.





=head2 MProcs

=over


=item B<mproc Lang::do [[strict sub body] [strict sub final [default :[]]]]>

Evaluate C<body> once and return its result. If C<final> is given, evaluate it after C<body> finishes.

=item B<mproc Lang::dofor [[sub 1 pr] [seq]]>

Call procedure C<pr> on each element in C<seq>, discarding the result. This is a slightly more compact, less flexible form of the C<for> loop.

=item B<mproc Lang::map [[sub 1 transPr] [seq]]>

Call procedure C<transPr> on each element in C<seq> and return another sequence containing the results of the calls on the corresponding input elements. The return value's type is compatible with C<seq>'s.

=item B<mproc Lang::reduce [[sub 1 filter] [seq]]>

Apply procedure C<filter> to every element of sequence C<seq> and return another sequence containing only the elements on which C<filter> returned a true value. The return value's type is compatible with C<seq>'s.

=item B<mproc Lang::repeat [[count] [sub 1 pr]]>

Evaluate procedure C<pr> C<count> times. C<pr> takes one argument, the itteration number starting from zero. Does nothing if C<count> is not greater than zero. Returns the result of the last evaluation of pr or nil if there is none.

=item B<mproc Lang::sort [[sub 2 ucmp] [seq]]>

Return a copy of C<seq> with the elements sorted according to C<ucmp>.

C<ucmp> should take two arguments and return -1, 0 or 1 depending on whether the first argument is less than, equal to or greater than the second argument. (This is the same interface as C<cmp>).

C<seq> is an object that implements the sequence protocol and the return value is constructed by the procedure returned by C<seq>'s C<maker> attribute.

=item B<mproc Lang::try [[strict sub [Error] tryBlock] [word catch [default :catch]] [strict sub [Error] catchBlock [default :[]]]]>

Evaluate a block, providing it with an C<Exception>. If the exception is thrown, the rest of the block is not evaluated. However, the optional second block (following the word 'catch') is evaluated.

Both blocks are given an argument named C<Error>. This is the C<Exception>. It may be treated as any other object--passed to procedures, stored in global variables, etc.--but it is a fatal runtime error if its C<throw> is called (for the first time) after the first block has finished executing.



=back

=head2 Procedures

=over


=item B<proc Lang::=== {lhs rhs}> B<(Built-in)>

Test if C<lhs> and C<rhs> are the same object.

=item B<proc Lang::apply {fun argList}> B<(Built-in)>

Call procedure C<fun> with the arguments in list C<argList> and returns the result of the call. C<argList> B<must> be a standard Deck list and not merely an object that implements the sequence protocol.

=item B<proc Lang::atput {seq index value}> B<(Built-in)>

Store a value in a sequence.

=item B<proc Lang::byteArray {args}> B<(Built-in)>

Return a ByteArray containing the arguments. Arguments must be integers with values between 0 and 255.

=item B<proc Lang::bytesSized {size}> B<(Built-in)>

Create an empty (zero-initialized) ByteArray that is C<size> bytes long.

=item B<proc Lang::chr {number}> B<(Built-in)>

Return the character represented by C<number> in the character set. If C<number> is not valid character in the current encoding, returns an empty string instead.

=item B<proc Lang::defined {name}> B<(Built-in)>

Test if there is a symbol named C<name> (a symbol) visible in the current context. Whether or not this test works on local names is undefined.

=item B<proc Lang::die {args}> B<(Built-in)>

Print the arguments (using the internal printer) concatenated together, then exit with an error status.

=item B<proc Lang::exit {status}> B<(Built-in)>

Exit immediately with exit status C<status>. C<status> must be a number. If it is not an integer, it is truncated down to the nearest integer value.

=item B<proc Lang::getMethod {object methodName}> B<(Built-in)>

Return the C<MethodCall> object that invokes the method named by symbol C<methodName> in object C<object>. If there is no matching method, the C<MethodCall> invokes C<doesNotUnderstand>.

This is almost never called explicitly. Usually, calls are generated by the macro C<-E<gt>>.

=item B<proc Lang::getSuperMethod {object methodName}> B<(Built-in)>

This is identical to C<getMethod> except that the method search starts at the superclass of C<object>.

It is usually invoked by the macro C<-E<gt>> and is not guaranteed to work unless C<object> is the caller's C<self>.

=item B<proc Lang::int {aNumber}> B<(Built-in)>

Return number C<aNumber> as an integer. C<aNumber> is truncated toward zero.

=item B<proc Lang::intern {aString}> B<(Built-in)>

Given string C<aString>, return the symbol containing the same text.

=item B<proc Lang::list {args}> B<(Built-in)>

Return a new list containing all of the arguments in the order they were given.

=item B<proc Lang::listSized {size}> B<(Built-in)>

Return an empty (nil-filled) list of size C<size>.

=item B<proc Lang::lookup {name}> B<(Built-in)>

Get the value of the variable named by symbol C<name> in the current context. If C<name> is undefined, it is a fatal error. Whether this can detect local names is currently undefined.

=item B<proc Lang::mkstr {args}> B<(Built-in)>

Return a string containing all of the arguments' B<internal> string representation (i.e. from the interpreter, B<not> the C<printable> attribute). This is used to expand double-quoted strings.

=item B<proc Lang::neg {aNumber}> B<(Built-in)>

Return number C<aNumber> negated (i.e. with its sign flipped, so negative if it was positive and positive if it was negative.)

=item B<proc Lang::new {class args}> B<(Built-in)>

Create and return a new instance of the class given by C<class>. The remaining arguments are passed to the new object's C<init> method. This is identical to invoking the class's C<new> method.

=item B<proc Lang::not {obj}> B<(Built-in)>

Return the boolean complement of C<obj>.

=item B<proc Lang::perlobj {obj}> B<(Built-in)>

Return a PerlObj wrapping C<obj>.

=item B<proc Lang::quote {obj}> B<(Built-in)>

Return a Quote object wrapping C<obj>.

Note: this does B<not> in any way affect the evaluation of of its argument. C<quote> is B<not> a special form. If you want to delay normal evaluation of an expression, use the quote operator (C<:>).

=item B<proc Lang::str2num {aString}> B<(Built-in)>

Parse C<aString> as the printable form of a numeric constant. All of the forms accepted by the Deck parser are also accepted by C<str2num>. If C<aString> does not contain a valid number, C<str2num> returns nil.

=item B<proc Lang::stringSized {size}> B<(Built-in)>

Create an empty string C<size> characters long.

=item B<proc Lang::subify {exprList args}> B<(Built-in)>

From the given arguments, create a list which will, when evaluated as an expression, return a sub. It is intended to aid in writing macros and provides standard argument handling for many system macros already.

C<exprList> is the body of the sub and must be a list or LoL. If it is not a LoL, it is automatically wrapped with another list, making it into a LoL.

C<args> can be a list of symbols or a number. If it is a list of symbols, those symbols form the sub's formal argument list. If it is a number, the argument list is generated with that many arguments named C<a> through C<z>. Naturally, C<args> must be between 0 and 26.

Note that C<subify> does no syntax checking at all. If you provide garbage input, you'll get garbage output.

=item B<proc Lang::subifyOrDelay {expr}> B<(Built-in)>

Create a list which, when evaluated as an expression, will return a sub that evaluates C<expr>. If C<expr> is a list, C<subifyOrDelay> will behave exactly like C<subify>. Otherwise, the sub will evaluate and return C<expr>, whatever it is.

=item B<proc Lang::unintern {aSymbol}> B<(Built-in)>

Given symbol C<aSymbol>, return a string containing the same text.

=item B<proc Lang::value {args}> B<(Built-in)>

Return the last item in the argument list. If none is given, return nil.

=item B<proc _::atput {seq index value}> B<(Built-in)>

Store a value in a sequence.

=item B<proc _::class {superclass body name}> B<(Built-in)>

Create the class specified by C<superclass> and C<body>. C<name> (a string) is not required to be the globalconst that typically references the class but itshould be. Implements macro C<class>.

=item B<proc _::class_ext {class body}> B<(Built-in)>

Implements macro C<_class_ext>

=item B<proc _::const {args}> B<(Built-in)>

Declare and initialize one or more consts.

=item B<proc _::defns {namespaceName}> B<(Built-in)>

Define a new namespace named by symbol C<namespaceName>.

=item B<proc _::docstring_get {key}> B<(Built-in)>

Return a list containing the docstring information for the object named by symbol C<key>. C<key> is typically a global variable.

The result is a list in one of the following forms:

=over

[:class I<name> I<builtin> I<superclass> I<docstring>]

[:proc I<name> I<builtin> I<args> I<docstring>]

[:method I<name> I<builtin> I<classname> I<methodname> I<args> I<docstring>]

[:attrib I<name> I<builtin> I<classname> :readable/:writeable/:public I<attrib-name> I<docstring>]

[:macro I<name> I<builtin> I<args> I<docstring>]

[:mproc I<name> I<builtin> I<args> I<docstring>]

=back

The first field is always a symbol and identifies the type of object being referenced and, by extension, the format of the rest of the list.

The second item is its name. The third (I<builtin>) is a boolean that indicates whether the object is built into the interpreter.

I<args> is the formal argument list and I<docstring> is a string containing the long-form POD-formatted documentation for the object.

I<superclass> and I<classname> are references to classes that may be associated with the object. Note that not all classes are named or are named correctly. However, this generally only happens to classes that do not contain docstrings.

Attributes also have the I<attrib-name> field, which is the name of the attribute, as opposed to the get/set method which implements it. In addition, its fifth item indicates its access mode.

=item B<proc _::docstring_keys {}> B<(Built-in)>

Return a list containing the keys (i.e. names) of all documented objects in memory. The list is sorted using Perl's C<cmp> operator. Keys are symbols and generally correspond to global variable names.

=item B<proc _::foreach {list fn}> B<(Built-in)>

Backend for the 'for'/'foreach' macro.

=item B<proc _::getMethod {object methodName}> B<(Built-in)>

Return the C<MethodCall> object that invokes the method named by symbol C<methodName> in object C<object>. If there is no matching method, the C<MethodCall> invokes C<doesNotUnderstand>.

This is almost never called explicitly. Usually, calls are generated by the macro C<-E<gt>>.

=item B<proc _::getSuperMethod {object methodName}> B<(Built-in)>

This is identical to C<getMethod> except that the method search starts at the superclass of C<object>.

It is usually invoked by the macro C<-E<gt>> and is not guaranteed to work unless C<object> is the caller's C<self>.

=item B<proc _::if {test trueSub falseSub}> B<(Built-in)>

Performs an 'if' comparison. This is the backend of a number of flow-control macros.

=item B<proc _::macro {name args body}> B<(Built-in)>

Defines a macro.

=item B<proc _::map {func seq}> B<(Built-in)>

Primitive implementation of 'map'.

=item B<proc _::mkstr {args}> B<(Built-in)>

Return a string containing all of the arguments' B<internal> string representation (i.e. from the interpreter, B<not> the C<printable> attribute). This is used to expand double-quoted strings.

=item B<proc _::mkstr_all {argList}> B<(Built-in)>

Like C<_::mkstr> but takes a single list of objects instead of multiple arguments.

=item B<proc _::mproc {name args body}> B<(Built-in)>

Define an mproc.

=item B<proc _::perlproc {name args bodyString}> B<(Built-in)>

Define a proc written in Perl with source code given in C<bodyString>. Implements C<perlproc>.

=item B<proc _::perluse {module}> B<(Built-in)>

Implement the C<perluse> statement.

=item B<proc _::proc {name args body final}> B<(Built-in)>

Defines a proc described by the arguments. Should only be invoked by the C<proc> macro.

=item B<proc _::puts {args}> B<(Built-in)>

Identical to C<_::say> except that it also prints a newline.

=item B<proc _::say {args}> B<(Built-in)>

Displays a printable representation of each of its arguments to stdout. The string representations of the arguments are generated internally, B<not> with the C<printable> attribute so C<_::say> (and C<_::puts>) will work on objects with a defective C<printable_get>.

=item B<proc _::set {name value}> B<(Built-in)>

Assigns a value to a variable.

=item B<proc _::sub {args body final}> B<(Built-in)>

Defines a sub.

=item B<proc _::use {module withTerm list}> B<(Built-in)>

Implements the C<use> statement.

=item B<proc _::value {args}> B<(Built-in)>

Return the last item in the argument list. If none is given, return nil.

=item B<proc _::var {args}> B<(Built-in)>

Declare and initialize one or more variables.

=item B<proc _::while {test body}> B<(Built-in)>

The back-end for a number of looping macros.



=back

=head2 Macros

=over


=item B<macro % {left right}> B<(Built-in)>

Expands to C<[left-E<gt>op_Mod right]>.

=item B<macro & {left right}> B<(Built-in)>

Expands to C<[left-E<gt>op_BitAnd right]>.

=item B<macro && {left right}> B<(Built-in)>

Perform a short-circuited logical AND. C<right> will only be evaluated if C<left> has evaluated to true.

=item B<macro * {left right}> B<(Built-in)>

Expands to C<[left-E<gt>op_Mult right]>.

=item B<macro ** {left right}> B<(Built-in)>

Expands to C<[left-E<gt>op_Pow right]>.

=item B<macro + {left right}> B<(Built-in)>

Expands to C<[left-E<gt>op_Add right]>.

=item B<macro - {left maybeRight}> B<(Built-in)>

If given two arguments, expands to C<[left->op_Sub maybeRight]> (i.e. ordinary subtraction). If C<maybeRight> is ommitted, expands to C<[neg left]> (i.e. negation).

=item B<macro -E<gt> {object message}> B<(Built-in)>

Performs a method lookup of RHS C<message> on LHS C<object> and returns the matching C<MethodLookup> object. If C<object> is the word C<super>, C<self> is used instead but the method search starts at the object's superclass.

Note that syntactic sugar in the compiler will implicitly wrap any bare C<-E<gt>> expression at the start of an infix expression with round brackets, making it infix. Hence, C<[foo->bar 1]> becomes C<[(foo->bar) 1]>.

=item B<macro . {object attribute}> B<(Built-in)>

Performs an attribute lookup. C<object.attribute> expands to C<[object->attribute_get]. However, the assignment macros C<=> and C<set> will expand to an C<attribute_set> call if the destination of the assignment is a C<.> expression.

In addition, the synactic sugar in the compiler will automatically wrap any C<expression . word> sequence in an infix expression with round brackets, making them infix. Hence, C<[add a.val b.val]> becomes C<[add (a.val) (b.val)]>.

=item B<macro E<sol> {left right}> B<(Built-in)>

Expands to C<[left-E<gt>op_Div right]>.

=item B<macro E<sol>E<sol> {left right}> B<(Built-in)>

Expands to C<[left-E<gt>op_DivTrunc right]>.

=item B<macro E<lt> {left right}> B<(Built-in)>

Expands to C<[left-E<gt>op_Lt right]>.

=item B<macro E<lt>E<lt> {left right}> B<(Built-in)>

Expands to C<[left-E<gt>op_LShift right]>.

=item B<macro E<lt>= {left right}> B<(Built-in)>

Expands to C<[left-E<gt>op_Lte right]>.

=item B<macro = {dest = value}> B<(Built-in)>

Assigns RHS C<value> to LHS C<value>. C<dest> is either a bare name, a list access (C<@>) expression or an attribute (C<.>) expression.

=item B<macro == {left right}> B<(Built-in)>

Expands to C<[left-E<gt>op_Equals right]>.

=item B<macro =E<gt> {args body}> B<(Built-in)>

Creates a C<sub>. C<args> and C<body> must be list constants of the sorts allowed by C<sub>.

Note that syntactic sugar in the compiler will automatically wrap any C<=E<gt>> expression in an infix expression with round brackets. Hence, C<[map {a} => {value (a*a)} l]> becomes C<[map ({a} => {value (a*a)}) l]>.

=item B<macro E<gt> {left right}> B<(Built-in)>

Expands to C<[left-E<gt>op_Gt right]>.

=item B<macro E<gt>= {left right}> B<(Built-in)>

Expands to C<[left-E<gt>op_Gte right]>.

=item B<macro E<gt>E<gt> {left right}> B<(Built-in)>

Expands to C<[left-E<gt>op_RShift right]>.

=item B<macro @ {left right}> B<(Built-in)>

Expands to C<[left-E<gt>at right]>.

=item B<macro ^ {left right}> B<(Built-in)>

Expands to C<[left-E<gt>op_BitXor right]>.

=item B<macro _class_ext {name body}> B<(Built-in)>

Defines extra methods and documentation for builtin classes. Do not use.

=item B<macro class {name superclass body}> B<(Built-in)>

Define a class named by word C<name>. Word C<superclass> is the name of the superclass and may be ommitted, in which case C<Struct> is assumed. C<body> is the class body and is expected to be a LoL.

=item B<macro const {args}> B<(Built-in)>

Declares one or more constants in the local scope.

=item B<macro for {item in list body}> B<(Built-in)>

Alias for C<foreach>.

=item B<macro foreach {item in list body}> B<(Built-in)>

Evaluates C<body> over each element in C<list> from start to end with a local variable C<item> set to reference the element. The second argument must be the word C<in>. This implements the standard C<foreach> loop. Argument C<body> is subified.

=item B<macro if {cond trueBlock else falseBlock}> B<(Built-in)>

Evaluate a sequence of instructions conditionally. Evaluates C<cond> and if the result is true, then evaluates C<trueBlock>. Otherwise, it evaluates C<falseBlock> if present (it is optional). This is the standard C<if> statement.

C<cond> can be C<subified> or C<delayed>; C<trueBlock> and C<falseBlock> are always subified. C<falseBlock> is optional. C<else> is the word 'else'; it is always optional and should be omitted if C<falseBlock> is also absent.

=item B<macro macro {name args body}> B<(Built-in)>

Declares a macro in the current module scope.

=item B<macro mproc {name args body}> B<(Built-in)>

Declares an mproc in the current module scope.

=item B<macro object {name superClass body}>

Define a class and declare a single instance of it in the current context. C<name> is the const which references the new object. C<superClass> is the class from which the new object's class is derived. C<body> is a LoL defining the class. The format is identical to the body of C<class>.

=item B<macro package {moduleName}> B<(Built-in)>

Declare this file to be the package named by word C<moduleName>. This is really a compiler directive and it is an error to use anywhere other than the first (non-trivial) line of a module.

=item B<macro perlproc {name args body}> B<(Built-in)>

Define a Perl function plus bindings to Deck. C<name> and C<args> are identical to C<proc> and friends but C<body> is a string constant containing Perl code.

=item B<macro perluse {name}> B<(Built-in)>

Force the Perl interpreter running udeck to load the Perl module named by C<name> via the C<require> statement. This module must be accessed via C<perlproc> functions.

=item B<macro proc {name args body final}> B<(Built-in)>

Declares a procedure in the current module scope. C<final> is optional. If C<body> and C<args> are also omitted, the statement instead creates a forward declaration of the procedure.

=item B<macro set {dest value}> B<(Built-in)>

Performs assignments. Prefix alias for C<=>.

=item B<macro sub {args body final}> B<(Built-in)>

Create a C<sub> (i.e. a closure) in the local scope and return it. C<args> is the list of arguments (in any of the acceptable formal argument formats) and C<body> is a LoL containing the sub's source code. C<args> and C<final> are both optional but if C<final> is present, C<args> B<must> also be present.

=item B<macro use {moduleName mode items}> B<(Built-in)>

Import the module named by word C<moduleName> into the current namespace. C<items> is the optional list of items to import, ignore or rename and C<mode> must be one of C<with>, C<without> or C<rename>. The last two arguments are optional.

=item B<macro var {args}> B<(Built-in)>

Declares one or more variables in the local scope.

=item B<macro while {cond block}> B<(Built-in)>

Repeatedly evaluate C<cond> followed by C<block> until the first time C<cond> evaluates false. This is the standard C<while> loop.

C<cond> can be C<subified> or C<delayed>; C<block> is always subified.

=item B<macro E<verbar> {left right}> B<(Built-in)>

Expands to C<[left-E<gt>op_BitOr right]>.

=item B<macro E<verbar>E<verbar> {left right}> B<(Built-in)>

Perform a short-circuited logical Or operation. C<right> is evaluated only if C<left> has evaluated to false.



=back

=head2 Classes


=over


=item B<Lang::ByteArray (Stringlike)>  B<-- Built-in>

A C<ByteArray> is a sequence of 8-bit bytes. Any sequence of bytes is allowed.

C<ByteArray> implements the sequence protocol but will fail if you attempt to store a value in it that is not an integer between 0 and 255.

I<Attributes>

=over

=item B<readable maker>

Sequence protocol: return a procedure which will create a collection suitable for holding the contents of self and which takes one argument, a number specifying the size. In this case, it's C<bytesSized>.

=item B<readable printable>

Return a human-readable textual represention of this object.

=back

I<Methods>

=over

=item B<method op_Add {otherBArray}>

C<+> operator, overloaded: Returns C<self> and C<obj> concatenated together. The result is the type returned by C<maker> (C<ByteArray> in this case). Note that C<obj> does B<not> have to be a C<ByteArray> but B<must> contain only bytes (i.e. integers between 0 and 255.

=item B<method op_Equals {obj}>

C<==> operator: True if C<obj> is also a ByteArray and all elements equal the corresponding element in C<obj>.

=item B<method shallowCopy {}>

Return a copy of C<self>.

=back

=item B<Lang::Class (Object)>  B<-- Built-in>

All classes (i.e. types) in Deck are themselves objects and those objects are instances of type C<Class>. This includes C<Class> itself.

C<Class> serves two purposes: to provide information about the class and to create new instances via its C<new> method.

I<Attributes>

=over

=item B<readable methods>

Return a C<List> of C<Symbols>, each one the name of a method implemented by B<this class> and B<not> one of its superclasses.

=item B<public name>

The class's name. Note that unnamed classes may exist and that the C<name> attribute is not necessarily the same as the global symbol (if present) that references the class. This is the common case but it is not guaranteed.

=item B<readable printable>

Return a human-readable textual represention of this object.

=item B<readable selectors>

Return a C<List> of C<Symbols>, each one the name of a method implemented by this method or one of its superclasses.

=item B<readable superclass>

Return a reference to this class's superclass. This can be C<nil> if the class does not have a superclass. Currently, only C<Object> is like that.

=back

I<Methods>

=over

=item B<method can {message}>

Test if this class implements a method named by C<message>. C<message> must be a symbol.

=item B<method new {args}>

Create a new instance of this class and return it. The argument list is passed to the new object's C<_init> method, which C<new> calls first.

=back

=item B<Lang::Exception (Struct)> 

Instances of C<Exception> represent error conditions and are used to recover from them or bring the program to a graceful halt. Instances are typically created by the C<try> mproc.

C<Exception> has three public fields:

=over

=item C<message> is a human-readable description of the error.

=item C<id> is a machine-parsable error message, typically a symbol.

=item C<info> is a C<List> of associated arguments.

=back

Typical C<Exceptions> wrap a continuation which will return control flow to some earlier context. Calling C<throw> invokes this continuation and exits the current procedure and all other callers up to the C<try> block that created it. C<throw> also deletes the continuation, turning subsequent calls to C<throw> into no-ops.

The global C<const> C<Fatal> references an Exception which will cause the current program to exit with an error.

I<Attributes>

=over

=back

I<Methods>

=over

=item B<method shallowCopy {}>

Make a copy of this C<Exception>. Note that all fields are shared across both instances.

=item B<method throw {msg args}>

Throw this Exception. If C<msg> is given (i.e. not a false value), store it in the C<message> field. If it is followed by a symbol (in C<args>), that value is stored in the C<id> field. The remaining arguments if present are stored in the C<info> field. Thus

=over 4

exc->throw 'Oh no!' :error 1 2 3 4 5

=back

is equivalent to

=over

exc.message = 'Oh no!' exc.id = :error exc.info = [list 1 2 3 4 5] exc->throw ''

=back

=back

=item B<Lang::Hash (Struct)> 

Instances of Hash are associative arrays (aka 'dictionaries' or 'hash tables') which map keys to values. The contents are accessed using the C<at> and C<atPut> methods so the C<@> operator can be used to access the contents.

Someday, any object will be a valid key but for now, the key must be a String, Symbol or Number.

(Actually, any object which implements the readable attribute C<hashKey> will work if the implementation returns a string and guarantees that the the strings are equal if and only if the objects are equal. This is deprecated, however as it will break the planned future implementation of Hash. Instead, you should compute the string and explicitly use it as the key. The current implementation is like this so I can use Perl hashes to do the heavy lifting. This let me slap together a useful Hash class in a few hours.)

(Also, I know that C<Hash> is a bad name for this class because it implies a specific underlying implementation, which is a no-no in OOP. I did it anyway because the term 'hash' has become common shorthand for associative arrays and C<Hash> is probably clearer to most programmers than C<Dictionary> or C<AssociativeArray>. It's also easier to type.

I<Attributes>

=over

=item B<readable keys>

Return a list containing all of the keys in C<self>.

=item B<readable keysAndValuePairs>

Return a list of 2-element lists, one for each item stored in C<self> with the first element in each pair being the key and the second being the value.

=item B<readable keysAndValues>

Return a list containing each key in C<self> immediately followed by the associated value.

=item B<readable printable>

Return a human-readable textual represention of this object.

=item B<readable size>

Return the number of items (i.e. key/value pairs) in C<self>.

=item B<readable values>

Return a list containing all of the values in C<self>.

=back

I<Methods>

=over

=item B<method _init {args}>

Object initializer.

=item B<method _initState {}>

Initialize C<perlHash>. It holds a reference to a Perl hash, which does the actual work.

=item B<method _setInitialValues {values}>

Given a list of key/value pairs, store each value in C<self> with the associated key.

=item B<method at {key}>

Retrieve the object in C<self> stored at C<key>. C<key> must be present or it is a fatal error. C<key> must be one of the supported key types.

=item B<method atPut {key value}>

Store C<value> in C<self> at C<key>. C<key> must be one of the supported key types.

=item B<method exists {key}>

Test if C<key> is present in C<self>. Returns true if present, false if not.

=item B<method op_Equals {obj}>

Implements the C<==> operator: tests for equality. Hashes are equal if their keys and associated values are all equal.

=item B<method removeKey {key}>

Remove the key/value pair associated with C<key> from C<self>.

=item B<method shallowCopy {}>

Create a new hash with the same contents.

=back

=item B<Lang::Interval (Struct)> 

Instances of C<Interval> mimic a list containing a consecutive series of numbers as defined by the C<new> arguments C<startVal>, C<endVal> and C<incrVal>, all Numbers truncated to the nearest integer. C<startVal> is the first number, C<endVal> is the last (possibly approximated) and C<incrVal> is the increment from one value to the next.

The main purpose of C<Interval> is to provide a way to do a for/foreach loop over a series of integers without having to create an actual array of integers. This allows you to do stuff like this:

C<for i in (1 .. 10000000) { ... }>

instead of

C<var x = 0; while (x < 10000000) { ... ; x = x + 1 }>

(The C<..> operator creates an C<Interval>.)

C<Intervals> implement the sequence protocol but C<atPut> fails with an error since they are naturally not writable.

I<Attributes>

=over

=item B<readable end>

The last value in C<self>.

=item B<readable isIndexable>

True. C<Intervals> are indexable.

=item B<readable isTrue>

This object's truth value. Like other sequences, true unless empty.

=item B<readable printable>

The human-friendly description of C<self>.

=item B<readable size>

Sequence Protocol: Number of (imaginary) items.

=back

I<Methods>

=over

=item B<method at {index}>

Sequence Protocol: Return the item at position C<index>. Indexes must be contiguous and start at zero. Negative indexes are subtracted from the list's size.

=item B<method atPut {index value}>

Dies with an error if called.

=item B<method op_Equals {other}>

C<==> operator: True if C<other> is also an C<Interval> containing the same sequence of numbers.

=item B<method shallowCopy {}>

Make a copy of this C<Interval>.

=back

=item B<Lang::List (Object)>  B<-- Built-in>

C<List> is the fundamental Deck list type. Unlike most Lispish languages, Deck does not present its lists as linked lists of cells. Instead, a Deck C<List> is an array (i.e. a 'vector') of object references whose individual items can be accessed with the C<at> and C<atPut> methods (usually hidden by the C<@> operator). The indexes start at zero and increase to the number of items minus one.

This is different from most Lispish languages, where a list is implemented as a linked list of pairs of references (CONS cells).

C<List> implements the sequence protocol: C<at>, C<atPut>, C<size>, C<maker> C<isIndexable> returns true.

I<Attributes>

=over

=item B<readable isIndexable>

Returns true, since C<List> implements the sequence protocol.

=item B<readable printable>

Return a human-readable textual represention of this C<List>.

=item B<readable size>

Sequence Protocol: Return the number of items in this object.

=back

I<Methods>

=over

=item B<method at {index}>

Sequence Protocol: Return the item at position C<index>. Indexes must be contiguous and start at zero. Negative indexes are subtracted from the list's size.

=item B<method atPut {index value}>

Sequence Protocol: Store C<value> at position C<index> and return C<value>. Indexes start at zero and must be contiguous. Negative indexes are subtracted from the list's size.

=item B<method op_Add {otherSeq}>

C<+> operator, overloaded: Returns C<self> and C<other> concatenated together. The result is the type returned by C<maker> (C<list> in this case).

=item B<method op_Equals {obj}>

C<==> operator: True if C<obj> is also a List and all elements equal (via C<op_Equals>) the corresponding element in C<obj>.

=item B<method shallowCopy {}>

Return a copy of C<self> without copying the items it references.

=back

=item B<Lang::Macro (Object)>  B<-- Built-in>

C<Macro> is the class of all Deck macros.

I<Attributes>

=over

=item B<readable isCallable>

Tell if instances of this class are callable. Yes, in this case.

=item B<readable printable>

Return a human-readable textual represention of this object.

=back

I<Methods>

=over

=item B<method shallowCopy {}>

C<Macros> are immutable so we just return the same instance.

=back

=item B<Lang::Method (Object)>  B<-- Built-in>

C<Method> is the class of all Deck methods.

I<Attributes>

=over

=item B<readable printable>

Return a human-readable textual represention of this object.

=back

I<Methods>

=over

=item B<method shallowCopy {}>

C<Methods> are immutable so we just return the same instance.

=back

=item B<Lang::MethodCall (Object)>  B<-- Built-in>

C<MethodCall> is the class of all method call objects. Method calls are callable objects that will call a specific method on a specific object, both of which are captured inside the C<MethodCall>.

Instances of C<MethodCall> are the result of a call to C<getMethod> or C<getSuperMethod> (which are usually called by the macro C<-E<gt>>).

I<Attributes>

=over

=item B<readable isCallable>

Tell if instances of this class are callable. Yes, in this case.

=item B<readable printable>

Return a human-readable textual represention of this object.

=back

I<Methods>

=over

=item B<method shallowCopy {}>

C<MethodCalls> are immutable so we just return the same instance.

=back

=item B<Lang::Nil (Object)>  B<-- Built-in>

C<Nil> is the type of the object representing uninitialized variables. There is only one instance, the global constant C<nil>. Unset variables are initialized to nil, as are empty lists.

I<Attributes>

=over

=item B<readable isNil>

Test if this object is C<nil>. Returns true.

=item B<readable printable>

Return a human-readable textual represention of this object.

=back

I<Methods>

=over

=item B<method shallowCopy {}>

Return C<self> since nil is immutable.

=back

=item B<Lang::Number (Object)>  B<-- Built-in>

C<Number> is the class of all (built-in) number types in Deck. Instances are floating-point values.

I<Attributes>

=over

=item B<readable hashKey>

Deprecated. Return a string suitable for representing this object as the key in a Perl hash. Used in class C<Hash>.

=item B<readable printable>

Return a human-readable textual represention of this object.

=back

I<Methods>

=over

=item B<method addNumber {num}>

Add self to number C<num>

=item B<method bitAndNumber {num}>

Return C<num> bitwise ANDed with C<self>. Both are first truncated to the nearest integer.

=item B<method bitOrNumber {num}>

Return C<num> bitwise ORed with C<self>. Both are first truncated to the nearest integer.

=item B<method bitXorNumber {num}>

Return C<num> bitwise XORed with C<self>. Both are first truncated to the nearest integer.

=item B<method divNumber {num}>

Return C<num> divided by C<self>.

=item B<method divTruncNumber {num}>

Return C<num> divided by C<self> and rounded toward zero.

=item B<method gtNumber {num}>

Test if C<num> is greater than C<self>

=item B<method gteNumber {num}>

Test if C<num> is greater than or equal to C<self>

=item B<method ltNumber {num}>

Test if C<num> is less than C<self>.

=item B<method lteNumber {num}>

Return true if C<num> is less than or equal to C<self>.

=item B<method modNumber {num}>

Return C<num> modulo self.

=item B<method multNumber {num}>

Return C<num> multiplied by C<self>.

=item B<method op_Add {obj}>

C<+> operator. Performs addition.

=item B<method op_BitAnd {obj}>

C<&> operator. Perform bitwise AND operation. Fractional arguments are first truncated toward zero.

=item B<method op_BitOr {obj}>

C<|> operator. Perform bitwise OR operation. Fractional arguments are first truncated toward zero.

=item B<method op_BitXor {obj}>

C<^> operator. Perform bitwise exclusive-OR operation. Fractional arguments are first truncated toward zero.

=item B<method op_Div {obj}>

C</> operator. Performs division.

=item B<method op_DivTrunc {obj}>

C<//> operator. Performs division, truncating to the nearest int.

=item B<method op_Equals {obj}>

Test if C<self> and C<obj> have the same numeric value. (Non-numbers clearly do not.)

=item B<method op_Gt {obj}>

C<E<gt>> operator. Test if C<self> is greater than C<obj>. This overrides the version in C<Object> for no good reason.

=item B<method op_Gte {obj}>

C<E<gt>=> operator. Test if C<self> is greater than or equal to C<self>. This overrides the version in C<Object> for no good reason.

=item B<method op_LShift {obj}>

C<E<lt>E<lt>> operator. Shift self left by C<obj>.

=item B<method op_Lt {obj}>

C<E<lt>> operator. Test if C<self> is less than C<obj>. This overrides the version in C<Object> for no good reason.

=item B<method op_Lte {obj}>

C<E<lt>=> operator. Performs greater-than-or-equal-to test.

=item B<method op_Mod {obj}>

C<%> operator. Performs the modulo operation.

=item B<method op_Mult {obj}>

C<*> operator. Performs multiplication.

=item B<method op_Pow {obj}>

C<**> operator. Return C<self> raised to the power of C<other>.

=item B<method op_RShift {obj}>

C<E<gt>E<gt>> operator. Shift self right by C<obj>.

=item B<method op_Sub {obj}>

C<-> operator. Performs subtraction.

=item B<method powNumber {num}>

Return C<num> raised to the power of C<self>.

=item B<method shallowCopy {}>

Return self, since Numbers are immutable.

=item B<method shiftLeft {num}>

Return C<num> shifted left by C<self>

=item B<method shiftRight {num}>

Return C<num> shifted right by C<self>

=item B<method subNumber {num}>

Subtract self from C<num>

=back

=item B<Lang::Object (none)>  B<-- Built-in>

C<Object> is the root class. All other classes in Deck are derived from Object.

C<Object> is a pure abstract base class. It cannot be instantiated.

I<Attributes>

=over

=item B<readable class>

Return the class of this object.

=item B<readable hashKey>

Deprecated. Return a string suitable for representing this object as the key in a Perl hash. By default, calling this is an error.

=item B<readable isCallable>

Tell if instances of this class are callable.

=item B<readable isIndexable>

Tests if this object can be treated as a sequence (i.e. implements the sequence protocol). If true, the object must implement at least C<at>, C<size> and C<maker> as expected and C<atPut> should either behave as expected as well or fail with an error.

=item B<readable isNil>

Returns a true value if this object is nil, false otherwise.

=item B<readable isTrue>

Return this object's truth value. Somewhat magical.

=item B<readable last>

Sequence Protocol: Return the index of the last item in this object.

=item B<readable maker>

Sequence protocol: return a procedure which will create a collection suitable for holding the contents of self and which takes one argument,a number specifying the size. It defaults to C<listSized>.

=item B<readable printable>

Return a human-readable textual represention of this object.

=item B<readable self>

Return this object.

=back

I<Methods>

=over

=item B<method _init {args}>

This is the message that each object receives when it is first created. Its implementation is expected to initialize the new object.

=item B<method _sanitizeIndex {index}>

Sequence Protocol: Given an index into a sequence, return the normal index for the object (i.e. an integer between 0 and the last index or die with an error if it cannot be mapped to a valid index.

In particular, C<_sanitizeIndex> replaces a negative index with the matching positive index. (Negative indexes are relative to the end of the sequence.)

=item B<method copy {}>

Make a copy of this object.

=item B<method doesNotUnderstand {name args}>

This method is called when the object receives a message it does not understand (i.e. there is no corresponding method implemented.)

Default behaviour is to exit with an error message.

=item B<method op_Equals {other}>

C<==> operator: Test if C<self> and C<other> are equal with respect to their types. Should be overridden by subclass; defaults to using C<===>.

=item B<method op_Gt {obj}>

Operator C<E<gt>>: Test if self is greather than C<obj>.

=item B<method op_Gte {obj}>

Operator C<E<gt>=>: Test if self is greater than or equal to C<obj>.

=item B<method op_Lt {obj}>

Operator C<E<lt>>: Test if self is less than C<obj>.

=item B<method op_Lte {obj}>

Operator C<E<lt>=>: Abstract method. Subclasses must implement this.

=item B<method shallowCopy {}>

Make a copy of this object without copying the objects it references.

=back

=item B<Lang::PerlObj (Object)>  B<-- Built-in>

C<PerlObj> is a wrapper around some Perl data. Perl functions created using C<perlproc> can return Perl data that has no meaningful representation inside Deck and these can then be passed to other Perl procedures.

For example, a Deck wrapper around a Perl library may use a C<PerlObj> to hold a reference to an instance of a class defined in the library.

There is no way to modify a PerlObj in Deck.

I<Attributes>

=over

=item B<readable printable>

Return a human-readable textual represention of this object.

=back

I<Methods>

=over

=item B<method shallowCopy {}>

C<MethodCalls> are immutable so we just return the same instance.

=back

=item B<Lang::Procedure (Object)>  B<-- Built-in>

C<Procedure> is the class of most Deck procedures (procs, subs, etc).

I<Attributes>

=over

=item B<readable isCallable>

Tell if instances of this class are callable. Yes, in this case.

=item B<readable printable>

Return a human-readable textual represention of this object.

=back

I<Methods>

=over

=item B<method shallowCopy {}>

C<Procedures> are immutable so we just return the same instance.

=back

=item B<Lang::Quote (Object)>  B<-- Built-in>

C<Quote> instances are used to represent quotation in Deck expressions. They are typically represented in Deck source code via the colon operator (C<:>).

Each C<Quote> contains a single data value which may be retrieved using the C<value> attribute. A C<Quote> in an expression evaluates to its wrapped value. For example, the compiler will evaluate this

C<[a b c]>

as an expression where C<a>, C<b> and C<c> are expected to be variables and C<a> is expected to reference something callable and so will attempt to call the callable at C<a> with arguments C<b> and C<c>.

On the other hand, this

C<:[a b c]>

will evaluate to C<[a b c]>, a C<List> of C<Symbols>.

Instances are created with the procedure C<quote> (but note that C<quote> is B<not> a special form; its argument is evaluated normally.)

In practice, you will rarely find references to C<Quote> in everyday code. Their purpose is to affect compilation and that's generally over with by the time it reaches your code. You will (probably) only ever need to use a C<Quote> when creating Deck expressions to be compiled later by the Deck compiler.

I<Attributes>

=over

=item B<readable printable>

Return a human-readable textual represention of this object.

=item B<readable value>

The thing being wrapped.

=back

I<Methods>

=over

=item B<method op_Equals {obj}>

C<==> operator: True if C<obj> is also a C<Quote> and both objects' values are also equal according to C<op_Equals>.

=item B<method shallowCopy {}>

Create a new C<Quote> wrapping the same object.

=back

=item B<Lang::String (Stringlike)>  B<-- Built-in>

C<String> instances contain human-readable text which can be printed to the console or stored in a file. The class implements the sequence protocol but the objects stored or retrieved from a C<String> must themselves be strings of length 1.

Unlike many other languages, Deck does not have a character type. Instead, strings are encoded in some manner and it is best not to make assumptions about the details. In particular, you should B<never> use a C<String> to hold arbitrary binary data as this will break when Deck switches to using UTF8. Use C<ByteArray> for that.

That being said, C<Strings> are currently 7-bit ASCII and all operations are performed within the C<C> locality.

I<Attributes>

=over

=item B<readable hashKey>

Deprecated. Return a string suitable for representing this object as the key in a Perl hash. Used in class C<Hash>.

=item B<readable isSpace>

Test if C<self> is all ASCII whitespace.

=item B<readable isVowel>

Return true if C<self> contains one character and that character is an ASCII vowel.

=item B<readable maker>

Sequence protocol: return a procedure which will create a collection suitable for holding the contents of self and which takes one argument, a number specifying the size. In this case, it's C<stringSized>.

=item B<readable ord>

Return the numeric code of the first character of self. If self is empty, returns 0. Note that while Deck currently encodes strings in ASCII or some variant, it is not safe to assume that this will continue in later versions.

=item B<readable printable>

Return a human-readable textual represention of this object; in this case just C<self>; a string is its own printable.

=back

I<Methods>

=over

=item B<method lowercase {}>

Return a copy of C<self> with all uppercase characters replaced with their lowercase equivalents.

=item B<method op_Add {otherString}>

C<+> operator, overloaded: Returns C<self> and C<otherString> concatenated together. The result is the type returned by C<maker> (C<String> in this case). Note that C<otherString> does B<not> have to be a string but B<must> contain only strings of length 1 (i.e. characters).

=item B<method op_Equals {obj}>

C<==> operator: True if C<obj> is also a C<String> or C<Symbol> and all characters match the the corresponding characters in C<obj>.

=item B<method op_Lte {other}>

C<E<lt>=> operator: lexically compares C<self> with C<other> (which B<must> be a C<String> or C<Symbol>) and returns true if self comes before C<other> or if they are equal. The other comparisons are implemented in C<Object>.

=item B<method shallowCopy {}>

Create and return a copy of C<self>.

=back

=item B<Lang::Stringlike (Object)>  B<-- Built-in>

This is the abstract base class for several classes representing various sequences of binary or specially-encoded data. It should not be used directly.

I<Attributes>

=over

=item B<readable isIndexable>

Returns true, since all C<Stringlike> subclasses implement the sequence protocol.

=item B<readable size>

Sequence Protocol: Return the number of items in this object.

=back

I<Methods>

=over

=item B<method at {index}>

Sequence Protocol: Return the item at position C<index>. Indexes must be contiguous and start at zero. Negative indexes are subtracted from the list's size.

=item B<method atPut {index value}>

Sequence Protocol: Store C<value> at position C<index> and return C<value>. Indexes start at zero and must be contiguous. Negative indexes are subtracted from the list's size. C<value> must be of a type that can be stored in this object.

=back

=item B<Lang::Struct (Object)>  B<-- Built-in>

C<Struct> is the base class for all traditional classes. A traditional class is a class whose data is stored in named fields.

This is an abstract base class and cannot be instantiated. All subclasses should implement the method C<init> to initialize the fields when an instance is created.

C<Struct> subclasses are typically instantiated using the C<new> method or procedure.

I<Methods>

=over

=item B<method _structShallowCopy {}>

Return a copy of C<self> with all instance variables referencing the same objects the original references. A subclass should use this to implement C<shallowCopy> only if the new copy does not interfere with the internal state of the original.

=item B<method shallowCopy {}>

Create a suitably shallow copy of self such that the copy cannot interfere with the operation of the original. (For example, if the original contains a private list that it modifies, that list should be copied. Otherwise, both instances will modify the same (formerly) private list.)

=back

=item B<Lang::Symbol (Stringlike)>  B<-- Built-in>

Symbols are mostly used to represent names in expressions. They are similar to strings in that they contain human-readable text. However, there are some notable differences:

=over

=item 1.

Symbols are immutable. C<atPut> will fail on one.

=item 2.

Symbols are unique. There is only ever one symbol with a particular value.

=back

C<Symbol> implements the sequence protocol but as mentioned above, the C<atPut> method will fail.

C<Symbols> can be converted to and from strings via the C<intern> and C<unintern> procedures. Symbol literals are created by prefixing the symbol with the C<:> character, e.g. C<:foo>. This works as expected, with the quote delaying evaluation and so yielding the symbol instead of the variable it would represent.

I<Attributes>

=over

=item B<readable hashKey>

Deprecated. Return a string suitable for representing this object as the key in a Perl hash. Used in class C<Hash>.

=item B<readable maker>

Sequence protocol: return a procedure which will create a collection suitable for holding the contents of self and which takes one argument, a number specifying the size. In this case, it's C<stringSized>.

=item B<readable printable>

Return a human-readable textual represention of this object.

=back

I<Methods>

=over

=item B<method op_Add {obj}>

C<+> operator, overloaded: Returns C<self> and C<obj> concatenated together. The result is the type returned by C<maker> (C<String> in this case). Note that C<obj> does B<not> have to be a C<String> or C<Symbol> but B<must> contain only strings of length 1 (i.e. characters).

=item B<method op_Equals {obj}>

C<==> operator: true if self === obj or if obj is a string with the same characters in it.

=item B<method op_Lte {other}>

C<E<lt>=> operator: See C<String-E<gt>op_Lte>.

=item B<method shallowCopy {}>

Symbols are immutable so just return C<self>.

=back

=back

