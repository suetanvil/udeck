
=head1 Deck Language Reference

=head1 Introduction

Deck is a modern Lispish general-purpose programming language.  It
features:

=over

=item * First-class functions

=item * Closures

=item * Dynamically-typed variables

=item * Automatic memory management and memory safety

=item * Macros

=item * List-structured source code

=back

It also has:

=over

=item * Infix expressions and a readable syntax

=item * A pervasive, modern object system

=item * Namespaces and packages

=item * Continuations

=item * An innovative exception system

=back

Deck has two goals: to be a useful general-purpose programming
language on par with Java or Python and to be completely explorable by
curious novice programmers.  This means that the final Deck
implementation needs to be a simple program written in Deck.

To accomplish this, Deck is a building-block language.  Outside of a
tiny core, all of Deck is just libraries written in Deck.

(The current implementation doesn't live up to this goal, but it's
heading that way.)



=head1 Syntax

Deck source code is currently expected to be 7-bit ASCII text,
although future versions may support other character sets as well.

=head2 Lines

Deck source code is read in as a sequence of lines.  These lines are
sometimes syntactically significant so it is important to be aware of
the rules.

A line runs from either the start of the input file or from the
character after the end of the previous line through to the next ASCII
newline character.  For example:

	line 1
	line 2
	line 3

In addition, a semicolon (C<;>) can be used as a logical line
separator instead:

	line 1; line 2; line 3

Conversely, it is possible to spread a logical line across multiple
physical lines by ending the line with a backslash (C<\>):

	line \
	1
	line \
	2
	line \
	3

Note that unlike other line-oriented languages (e.g. Tcl and Unix
shells), the backslash is not an escaped newline.  You may put B<any>
whitespace or comment after a backslash and it will continue to mean
the same thing:

	line \    # this is a comment
	1
	line \    # so is this
	2
	line \    # and this
	3

Note: How Deck handles newlines from different platforms
(LF vs CR+LF vs CR) is currently dependent on the underlying Perl
interpreter.  This could be considered a bug.


=head2 Comments

Deck comments begin with a pound sign (C<#>, aka number sign, aka
octothorp) and run to the end of the physical line:

	foo     # this is a comment

Comments end at the B<physical> line: semicolons and backslashes do
not have an effect on comments:

	bar     # this is a comment; this is still the comment
	quux    # this is a new line \
	baz     # this is not part of the previous line's comment

For parsing purposes, comments are considered whitespace.


=head2 POD Regions

Deck also supports POD documentation.  Specifically, any line
beginning with an equal sign (C<=>) followed by a series of "word"
characters (alphanumeric plus C<_>) and optional other text after a
space denotes the start of a POD region.  The Deck interpreter will
ignore all subsequent input lines until it comes upon a line beginning
with C<=cut>.  

The C<=cut> may optionally be followed by a space and
then other text but must end with an actual newline.

POD documents inside multi-line strings are considered part of the
string and are parsed as such.

See L<perlpod> for a better explanation of POD.


=head2 Literals

Deck supports the following data literals:

=head3 Numbers

Deck currently only implements a single Number type but there are
multiple literal forms.  They are:

	12345			# Decimal integer
	0456			# Also decimal--leading zeroes are ignored
	-123.456		# Negative float
	0xDEADBEEF		# Hex literal
	0b10101010		# Binary literal

Note that there is no octal form.  Unlike most C-like languages, a
leading zero in an integer literal does not indicate an octal
constant.

In addition, numeric literals may contain underscores (C<_>).  These
are ignored by the parser and so can be used to make your numbers more
readable:

	1_000_000		# One. Million. Dollars.

The underscore can appear anywhere in a number except for the
beginning:

	_3.14159		# WRONG!

This is needed to distinguish between numbers and symbols.


=head3 Strings

Deck has two kinds of strings: single-quoted strings and double-quoted
strings.  Both evaluate to the same kind of internal object but the
quote determines how they are parsed.

Both kinds of strings can be spread across multiple lines.

=head4 Single-Quoted Strings

Single-quoted strings are delimited by one or more single quote
characters (C<'>).  The text inside a single-quoted string is not
altered in any way.  It is stored literally without any kind of
escaping or interpolation:

	'Hello, world!'

Because quotes are likely to appear in the text with no way to escape
them, you can use a series of quotes as the delimiter instead of a
single quote:

	'''I don't think this will be a problem. Nor will "''" be.'''

Note that the delimiter B<must> have an B<odd> number of quote
characters.  Otherwise, it will look like an empty string (i.e. an
odd-number-sized delimiter followed by the closing delimiter.):

	''''Hello, world!''''			# WRONG!

	''''''							# Empty string

As a special case, any even number of single quotes is parsed as an
empty string.


=head4 Double-Quoted Strings

Double-quoted strings allow interpolation and escaping.  As in Perl
and C-family languages, the backslash character is used as the escape:

	"She said, \"That's what he said!\""

In addition, Deck implements a subset of Perl's escape sequences:

	\t		tab
	\n		newline
	\r		return
	\a		bell
	\f		form feed

For example:

	"line 1\nline 2\nline 3\n"

The backslash also escapes the other special characters:

	\$		Dollar sign (C<$>)
	\@		At sign (C<@>)
	\\		backslash (C</>)

For example:

	"\\Win \$\$\$\$\$ \@ my online casino!\\"

The C<$> and C<@> require some special attention.

Deck provides something like Perl-style variable interpolation.  If a
string contains a dollar sign (C<$>) followed by a name (and possibly
bracketted by curly brackets (C<{> and C<}>)), it will be replaced by
the value of the variable's printable form:

	x = "foo"
	puts "$x $x"				# "foo foo"
	puts "${x}bar"				# "foobar"

Similarly, an at-sign (C<@>) followed by the name of a list will
expand to the printable form of each element in the list separated by a
single space.  If the variable is not a list, it is expanded in the
same way as the C<$> for above:

	var x = :["foo" "bar" "quux"]
	puts "@x"					# "foo bar quux"
	x = 42
	puts "$x"					# "42"

Note that C<@> expansion only works for items of the type List.
Datatypes that mimic a List sufficiently well do not get expanded like
one.  However, this may change in a future release.

B<Beware:> Double-quoted strings are sometimes converted into more
complex expressions by the parser.  This can react badly with certain
other constructs to put a non-string where a string is expected.  For
example, if a procedure contains this docstring:

	proc foo {x} {
		"do the foo thing"
		...
	}

everything will be fine.  However, if you add an interpolation:

	proc foo {x} {
		"do the foo thing to $x"
		...
	}

what you're actually doing is this:

	proc foo {x} {
		[_::mkstr "do the foo thing to " x]
		...
	}

which is not only not a docstring but will attempt to call a string as
a function.

So remember: a double-quoted string is a true string if an only if it
does not contain an unescaped C<@> or C<$>.

Note: Deck currently has two printable forms, one from the C<printable>
attribute and the other coming from within.  String interpolation
currently uses the internal (wrong) one.  This Will Be Fixed.


=head2 Delimiters

Deck parses the following characters as special delimiters:


=over

=item 1) C<{> and C<}>, the curly brackets

=item 2) C<(> and C<)>, the round brackets

=item 3) C<[> and C<]>, the square brackets

=item 4) C<:>, the quote delimiter

=back

The first three items are the parentheses Deck supports.

The colon (C<:>) is used to quote (i.e. delay evaluation) of the thing
following it.  See L<Quoting> below.

=head2 Symbols

Symbols (aka words, aka names) are generally used as the names of
variables and constants.  There are two forms of symbols:

Textual symbols take the same form as most modern programming
languages' variables: an alphabetic character or the underscore (C<_>)
followed by zero or more "word" characters (i.e. alphanumerics or
underscore).  Examples:

	foo
	_foo42
	this_is_a_variable
	_45			# Tricky: a variable, NOT a number

Operators consist of one or more of any of the following "operator"
characters:

	C<->, C<.>, C<|>, C<!>, C<@>, C<$>, C<%>, C<^>, C<&>, C<+>, C<=>,
	C<?>,  C<E<lt>>, C<E<gt>>, C</>

For example:

	a + b

Operators may be prefixed by the backslash (C<\>).  This does not
change the symbol but sometimes provides a hint to the parse (see
B<Expressions> below).  For example:

	++ == \++			# This expression is true--they are the same symbol


=head2 Lists

Lists consist of zero or more items surrounded by square brackets
(C<[> and C<]>) and separated by whitespace.  They will nearly always
need to be preceded by the quote operator (C<:>) to keep them from
being treated as prefix expressions:

	:[1 "two" 3]			# Simple list
	:[]						# Empty list
	:["foo" "bar" [1 2 3]]	# Nested list

Symbols in lists do not need to be quoted:

	:[+ a b]

Sublists may also be in infix form.

	:[+ a (b & c)]			# Nested list with infix sublist

Note that there are a few special cases.  These are described in
L<Syntactic Sugar> below.

(As an aside, Lisp/Scheme hackers should be aware that the underlying
data structure of a Deck list is an array (aka a vector), B<not> a
linked list of CONS cells.  This is explained in more detail below.)


=head2 Expressions

Deck expressions ultimately take the form of Lisp-style prefix
expressions but the parser will also accept several more readable
forms and convert them into simple prefix expressions.


=head3 Quoting

The colon (C<:>) is Deck's quote symbol.  It is roughly the same as
the single quote (C<'>) in Scheme and Common Lisp.  A quoted
expression is any Deck expression following a quote:

	:42
	:[1 2 3]
	:foo

The quote prevents the thing from following it from being evaluated.
Instead, the result of a quote expression is the thing being quoted.
A quoted list returns the list itself:

	:[foo bar quux]

The unquoted list

	[foo bar quux]

would attempt to look up C<foo>, C<bar> and C<quux>, then call C<foo>
with the other values as arguments.

In the same way, quoting a symbol returns the symbol instead of its
value:

	:foo		# symbol :foo
	foo			# value of variable 'foo'

Other literals (single-quoted strings and numbers) yield themselves
when quoted.  Double-quoted strings yield either the string (if
there's no interpolation) or the quoted interpolation expression.

The various expression transformations that happen below (i.e. infix
expressions, LoLs and prefix syntactic sugar) are all done before the
expression is quoted.  In other words, quoting does not prevent those
transformations.

Note that the quote is a syntactic structure rather than a function.
The parser creates a quote expression when it sees the colon.  It does
not attempt to look up the value of the variable C<:> and call it as a
function.

The quote and the next expression together make up a single
expression.  This has higher precedence than anything else except for
parentheses.


=head3 Prefix Expressions

Deck prefix expressions are simple unquoted lists.  Each item in the
list is first recursively evaluated from left to right.  The first
expression in the list is expected to evaluate to a callable
function.  This function is called with the remaining items passed to
it as arguments:

	[+ 1 3]									# Simple example
	[[getHook :panic] "Oh no!"]				# Complex example
	
The semantics of this are explained in more detail below.

=head4 Syntactic Sugar

As a special exception to the list parsing rules, the following
symbols are always treated as infix expressions:

	C<=E<gt>>, C<.>
	C<-E<gt>>

The first two have the same precedence and the third has lower
precedence.

For any of the above operators, the sequence C<*expr1* *op* *expr2*> is
automatically treated as a parenthesized infix expression and becomes
C<[*op* *expr1* *expr2*]>.

So,

	[foo b.c]				becomes		[foo [. b c]]
	[x->y 42]				becomes		[[-> x y] 42]
	[bar x => y]			becomes		[bar [=> x y]]

It is an error to start or end an infix expression with one of these
operators:

	[-> a b]			# WRONG!

This auto-infix behaviour can be disabled by prefixing the operator
with a backslash (C<\>) character.  This does not alter the meaning of
the token but will disable the syntactic sugar:

	[foo b \. c]
	[x \-> y 42]
	[bar x \=> y]
	[\-> a b]


The C<=E<gt>> is bound to a macro that creates closures.  The C<.>
operator is used to access object attributes and the C<-E<gt>>
operator is used to look up methods in objects.


=head3 Infix Expressions

Any Deck expression surround by parentheses (aka round brackets, C<(>
and C<)>) is parsed as an infix expression.  The operator precedence
in decreasing order are as follows:

		. @ =>
		->
		**
		* / // %
		+ -
		<< >> >>> <<<
		== === != !== < > <= >= <=>
		&
		| ^
		&&
		||
		(user operators)			  
		=

All operators are left-associative except for C<=>.

Any other sequence of operator characters is also valid as an infix
operator but will have second-lowest precedence:

	(a !!! 2)			# does whatever !!! is defined to do

Like the syntactic sugar above, infix expressions are just another
syntactic form for basic Deck expressions.  The parser immediately
converts infix expressions to the equivalent prefix expression.  This
is true even if the expression is quoted:

	:(a + b * c)		# Yields [+ a [* b c]]

Infix expressions need to have an odd number of items with unescaped
operators in all of the even-numbered positions:

	(c / d & f)			# Right
	(c \+ d)			# WRONG!!!
	(c d e)				# WRONG!!!

The odd-numbered items may also be operators:

	(addOp = +)

(But be warned that this will not work in a LoL line.)

As a special case, a one-item infix expression is equivalent to just
the item:

	(a) === a
	:(a) === a
	

=head4 Negation

The C<-> operator with one argument negates that argument.  In this
case, it must be a B<prefix> expression.  There is no infix negation.
However, numeric constants may begin with a C<-> to indicate that they
are negative and those may be used in an infix expression.

Specifically:

	(a + -3)			# Correct. -3 is one token.
	(a + [- b])			# Correct. Infix negate on b
	(a + [neg b])		# Correct.
	(a + -b)			# ERROR
	(a + (-b))			# ERROR


=head3 LoLs

LoLs (Line-oriented Lists or Lists of Lists) are another form of Deck
expression.  Each LoL is delimited by braces (C<{> and C<}>) and is
immediately converted into a quoted list containing zero or more other
lists.

LoLs use line boundaries instead of brackets as the delimiters of
their sublists.  Specifically, a LoL line starts at	the end of the
previous LoL line (or the start of the LoL if this is the first line)
and ends at the following line-end (or the end of the LoL if this is
the last item) in which all brackets opened in this line have been
B<closed>.

Examples:

	{
		line 1					# First Entry

		line 2 {				# Second entry
			continuing...		# Second entry continued
		} and done!				# Second entry finished

		line 3 [1 2 3			# Third entry starts
			4 3]				# Third entry ends
	}

LoL lines are logical lines (as described above) and so are subject to
C<;> and C<\>.  In addition, comments are ignored as are empty lines
(i.e. lines containing no non-whitespace characters):

	{							# Empty line.  Ignored
		line 1 \				# Item 1 starts
		continued				#  ...and continues

		line 2 ; line 3; line 4	# Next three items
	}	

Deck source files are implicitly LoLs, as is the interactive command
prompt.  They differ from ordinary functions a little in that each
toplevel line is evaluated immediately before the next line is read.




=head1 Data

Deck has a number of built-in data types

=head2 Basic Types


=head2 Derived Types



=head2 Booleans

=head3 Stupid Boolean Tricks



=head1 Procedures

=head2 Expression Evaluation

=head2 Toplevels

=head2 Procs

=head2 Closures

=head2 Final Blocks

=head2 Continuations


=head1 Macros

=head2 Proper Macros

=head2 MProcs

=head3 MProc Syntax



=head1 Objects

=head2 The Metaclass System

=head2 Method Lookup Semantics

=head2 Basic Classes and Struct

=head2 Defining Classes

=head3 Methods

=head4 Private methods

=head4 op_*

=head3 Fields and Attributes

=head3 The 'class' macro

=head3 The 'object' macro



=head1 Namespaces

=head2 Defining Modules

=head3 Private Names

=head2 Importing Modules

=head2 Local vs Qualified names

=head2 Default Namespaces

=head2 Reserved Namespaces



=head1 Bugs


