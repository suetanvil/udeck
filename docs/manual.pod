
=head1 Deck Language Reference

=head1 Introduction

Deck is a modern Lispish general-purpose programming language.  It
features:

=over

=item * First-class functions

=item * Closures

=item * Dynamically-typed variables

=item * Automatic memory management and memory safety

=item * Macros

=item * List-structured source code

=back

It also has:

=over

=item * Infix expressions and a readable syntax

=item * A pervasive, modern object system

=item * Namespaces and packages

=item * Continuations

=item * An innovative exception system

=back

Deck has two goals: to be a useful general-purpose programming
language on par with Java or Python and to be completely explorable by
curious novice programmers.  This means that the final Deck
implementation needs to be a simple program written in Deck.

To accomplish this, Deck is a building-block language.  Outside of a
tiny core, all of Deck is just libraries written in Deck.

(The current implementation doesn't live up to this goal, but it's
heading that way.)



=head1 Syntax

Deck source code is currently expected to be 7-bit ASCII text,
although future versions may support other character sets as well.

=head2 Lines

Deck source code is read in as a sequence of lines.  These lines are
sometimes syntactically significant so it is important to be aware of
the rules.

A line runs from either the start of the input file or from the
character after the end of the previous line through to the next ASCII
newline character.  For example:

	line 1
	line 2
	line 3

In addition, a semicolon (C<;>) can be used as a logical line
separator instead:

	line 1; line 2; line 3

Conversely, it is possible to spread a logical line across multiple
physical lines by ending the line with a backslash (C<\>):

	line \
	1
	line \
	2
	line \
	3

Note that unlike other line-oriented languages (e.g. Tcl and Unix
shells), the backslash is not an escaped newline.  You may put B<any>
whitespace or comment after a backslash and it will continue to mean
the same thing:

	line \    # this is a comment
	1
	line \    # so is this
	2
	line \    # and this
	3

Note: How Deck handles newlines from different platforms
(LF vs CR+LF vs CR) is currently dependent on the underlying Perl
interpreter.  This could be considered a bug.


=head2 Comments

Deck comments begin with a pound sign (C<#>, aka number sign, aka
octothorp) and run to the end of the physical line:

	foo     # this is a comment

Comments end at the B<physical> line: semicolons and backslashes do
not have an effect on comments:

	bar     # this is a comment; this is still the comment
	quux    # this is a new line \
	baz     # this is not part of the previous line's comment

For parsing purposes, comments are considered whitespace.


=head2 POD Regions

Deck also supports POD documentation.  Specifically, any line
beginning with an equal sign (C<=>) followed by a series of "word"
characters (alphanumeric plus C<_>) and optional other text after a
space denotes the start of a POD region.  The Deck interpreter will
ignore all subsequent input lines until it comes upon a line beginning
with C<=cut>.  

The C<=cut> may optionally be followed by a space and
then other text but must end with an actual newline.

POD documents inside multi-line strings are considered part of the
string and are parsed as such.

See L<perlpod> for a better explanation of POD.


=head2 Literals

Deck supports the following data literals:

=head3 Numbers

Deck currently only implements a single Number type but there are
multiple literal forms.  They are:

	12345			# Decimal integer
	0456			# Also decimal--leading zeroes are ignored
	-123.456		# Negative float
	0xDEADBEEF		# Hex literal
	0b10101010		# Binary literal

Note that there is no octal form.  Unlike most C-like languages, a
leading zero in an integer literal does not indicate an octal
constant.

In addition, numeric literals may contain underscores (C<_>).  These
are ignored by the parser and so can be used to make your numbers more
readable:

	1_000_000		# One. Million. Dollars.

The underscore can appear anywhere in a number except for the
beginning:

	_3.14159		# WRONG!

This is needed to distinguish between numbers and symbols.


=head3 Strings

Deck has two kinds of strings: single-quoted strings and double-quoted
strings.  Both evaluate to the same kind of internal object but the
quote determines how they are parsed.

Both kinds of strings can be spread across multiple lines.

=head4 Single-Quoted Strings

Single-quoted strings are delimited by one or more single quote
characters (C<'>).  The text inside a single-quoted string is not
altered in any way.  It is stored literally without any kind of
escaping or interpolation:

	'Hello, world!'

Because quotes are likely to appear in the text with no way to escape
them, you can use a series of quotes as the delimiter instead of a
single quote:

	'''I don't think this will be a problem. Nor will "''" be.'''

Note that the delimiter B<must> have an B<odd> number of quote
characters.  Otherwise, it will look like an empty string (i.e. an
odd-number-sized delimiter followed by the closing delimiter.):

	''''Hello, world!''''			# WRONG!

	''''''							# Empty string

As a special case, any even number of single quotes is parsed as an
empty string.


=head4 Double-Quoted Strings

Double-quoted strings allow interpolation and escaping.  As in Perl
and C-family languages, the backslash character is used as the escape:

	"She said, \"That's what he said!\""

In addition, Deck implements a subset of Perl's escape sequences:

	\t		tab
	\n		newline
	\r		return
	\a		bell
	\f		form feed

For example:

	"line 1\nline 2\nline 3\n"

The backslash also escapes the other special characters:

	\$		Dollar sign (C<$>)
	\@		At sign (C<@>)
	\\		backslash (C</>)

For example:

	"\\Win \$\$\$\$\$ \@ my online casino!\\"

The C<$> and C<@> require some special attention.

Deck provides something like Perl-style variable interpolation.  If a
string contains a dollar sign (C<$>) followed by a name (and possibly
bracketted by curly brackets (C<{> and C<}>)), it will be replaced by
the value of the variable's printable form:

	x = "foo"
	puts "$x $x"				# "foo foo"
	puts "${x}bar"				# "foobar"

Similarly, an at-sign (C<@>) followed by the name of a list will
expand to the printable form of each element in the list separated by a
single space.  If the variable is not a list, it is expanded in the
same way as the C<$> for above:

	var x = :["foo" "bar" "quux"]
	puts "@x"					# "foo bar quux"
	x = 42
	puts "$x"					# "42"

Note that C<@> expansion only works for items of the type List.
Datatypes that mimic a List sufficiently well do not get expanded like
one.  However, this may change in a future release.

B<Beware:> Double-quoted strings are sometimes converted into more
complex expressions by the parser.  This can react badly with certain
other constructs to put a non-string where a string is expected.  For
example, if a procedure contains this docstring:

	proc foo {x} {
		"do the foo thing"
		...
	}

everything will be fine.  However, if you add an interpolation:

	proc foo {x} {
		"do the foo thing to $x"
		...
	}

what you're actually doing is this:

	proc foo {x} {
		[_::mkstr "do the foo thing to " x]
		...
	}

which is not only not a docstring but will attempt to call a string as
a function.

So remember: a double-quoted string is a true string if an only if it
does not contain an unescaped C<@> or C<$>.

Note: Deck currently has two printable forms, one from the C<printable>
attribute and the other coming from within.  String interpolation
currently uses the internal (wrong) one.  This Will Be Fixed.


=head2 Delimiters

Deck parses the following characters as special delimiters:


=over

=item 1) C<{> and C<}>, the curly brackets

=item 2) C<(> and C<)>, the round brackets

=item 3) C<[> and C<]>, the square brackets

=item 4) C<:>, the quote delimiter

=back

The first three items are the parentheses Deck supports.

The colon (C<:>) is used to quote (i.e. delay evaluation) of the thing
following it.  See L<Quoting> below.

=head2 Symbols

Symbols (aka words, aka names) are generally used as the names of
variables and constants.  There are two forms of symbols:

Textual symbols take the same form as most modern programming
languages' variables: an alphabetic character or the underscore (C<_>)
followed by zero or more "word" characters (i.e. alphanumerics or
underscore).  Examples:

	foo
	_foo42
	this_is_a_variable
	_45			# Tricky: a variable, NOT a number

Operators consist of one or more of any of the following "operator"
characters:

	C<->, C<.>, C<|>, C<!>, C<@>, C<$>, C<%>, C<^>, C<&>, C<+>, C<=>,
	C<?>,  C<E<lt>>, C<E<gt>>, C</>

For example:

	a + b

Operators may be prefixed by the backslash (C<\>).  This does not
change the symbol but sometimes provides a hint to the parse (see
B<Expressions> below).  For example:

	++ == \++			# This expression is true--they are the same symbol


=head2 Lists

Lists consist of zero or more items surrounded by square brackets
(C<[> and C<]>) and separated by whitespace.  They will nearly always
need to be preceded by the quote operator (C<:>) to keep them from
being treated as prefix expressions:

	:[1 "two" 3]			# Simple list
	:[]						# Empty list
	:["foo" "bar" [1 2 3]]	# Nested list

Symbols in lists do not need to be quoted:

	:[+ a b]

Sublists may also be in infix form.

	:[+ a (b & c)]			# Nested list with infix sublist

Note that there are a few special cases.  These are described in
L<Syntactic Sugar> below.

(As an aside, Lisp/Scheme hackers should be aware that the underlying
data structure of a Deck list is an array (aka a vector), B<not> a
linked list of CONS cells.  This is explained in more detail below.)


=head2 Expressions

Deck expressions ultimately take the form of Lisp-style prefix
expressions but the parser will also accept several more readable
forms and convert them into simple prefix expressions.

=head3 Prefix Expressions

Deck prefix expressions are simple unquoted lists.  Each item in the
list is first recursively evaluated from left to right.  The first
expression in the list is expected to evaluate to a callable
function.  This function is called with the remaining items passed to
it as arguments:

	[+ 1 3]									# Simple example
	[[getHook :panic] "Oh no!"]				# Complex example
	
The semantics of this are explained in more detail below.

=head4 Syntactic Sugar

As a special exception to the list parsing rules, the following
symbols are always treated as infix expressions:

	C<=E<gt>>, C<.>
	C<-E<gt>>

The first two have the same precedence and the third has lower
precedence.

For any of the above operators, the sequence C<*expr1* *op* *expr2*> is
automatically treated as a parenthesized infix expression and becomes
C<[*op* *expr1* *expr2*]>.

So,

	[foo b.c]				becomes		[foo [. b c]]
	[x->y 42]				becomes		[[-> x y] 42]
	[bar x => y]			becomes		[bar [=> x y]]







=head3 Infix Expressions

=head3 LoLs

=head3 Quoting




=head1 Data

=head2 Types

=head2 Booleans

=head3 Stupid Boolean Tricks



=head1 Procedures

=head2 Expression Evaluation

=head2 Toplevels

=head2 Procs

=head2 Closures

=head2 Final Blocks

=head2 Continuations


=head1 Macros

=head2 Proper Macros

=head2 MProcs

=head3 MProc Syntax



=head1 Objects

=head2 The Metaclass System

=head2 Method Lookup Semantics

=head2 Basic Classes and Struct

=head2 Defining Classes

=head3 Methods

=head4 Private methods

=head4 op_*

=head3 Fields and Attributes

=head3 The 'class' macro

=head3 The 'object' macro



=head1 Namespaces

=head2 Defining Modules

=head3 Private Names

=head2 Importing Modules

=head2 Local vs Qualified names

=head2 Default Namespaces

=head2 Reserved Namespaces



=head1 Bugs


