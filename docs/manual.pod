
=head1 Deck Language Reference

=head1 Introduction

Deck is a modern Lispish general-purpose programming language.  It
features:

=over

=item * First-class functions

=item * Closures

=item * Dynamically-typed variables

=item * Automatic memory management and memory safety

=item * Macros

=item * List-structured source code

=back

It also has:

=over

=item * Infix expressions and a readable syntax

=item * A pervasive, modern object system

=item * Namespaces and packages

=item * Continuations

=item * An innovative exception system

=back

Deck has two goals: to be a useful general-purpose programming
language on par with Java or Python and to be completely explorable by
curious novice programmers.  This means that the final Deck
implementation needs to be a simple program written in Deck.

To accomplish this, Deck is a building-block language.  Outside of a
tiny core, all of Deck is just libraries written in Deck.

(The current implementation doesn't live up to this goal, but it's
heading that way.)



=head1 Syntax

Deck source code is currently expected to be 7-bit ASCII text,
although future versions may support other character sets as well.

=head2 Lines

Deck source code is read in as a sequence of lines.  These lines are
sometimes syntactically significant so it is important to be aware of
the rules.

A line runs from either the start of the input file or from the
character after the end of the previous line through to the next ASCII
newline character.  For example:

	line 1
	line 2
	line 3

In addition, a semicolon (C<;>) can be used as a logical line
separator instead:

	line 1; line 2; line 3

Conversely, it is possible to spread a logical line across multiple
physical lines by ending the line with a backslash (C<\>):

	line \
	1
	line \
	2
	line \
	3

Note that unlike other line-oriented languages (e.g. Tcl and Unix
shells), the backslash is not an escaped newline.  You may put B<any>
whitespace or comment after a backslash and it will continue to mean
the same thing:

	line \    # this is a comment
	1
	line \    # so is this
	2
	line \    # and this
	3

Note: How Deck handles newlines from different platforms
(LF vs CR+LF vs CR) is currently dependent on the underlying Perl
interpreter.  This could be considered a bug.


=head2 Comments

Deck comments begin with a pound sign (C<#>, aka number sign, aka
octothorp) and run to the end of the physical line:

	foo     # this is a comment

Comments end at the B<physical> line: semicolons and backslashes do
not have an effect on comments:

	bar     # this is a comment; this is still the comment
	quux    # this is a new line \
	baz     # this is not part of the previous line's comment

For parsing purposes, comments are considered whitespace.


=head2 POD Regions

Deck also supports POD documentation.  Specifically, any line
beginning with an equal sign (C<=>) followed by a series of "word"
characters (alphanumeric plus C<_>) and optional other text after a
space denotes the start of a POD region.  The Deck interpreter will
ignore all subsequent input lines until it comes upon a line beginning
with C<=cut>.  

The C<=cut> may optionally be followed by a space and
then other text but must end with an actual newline.

POD documents inside multi-line strings are considered part of the
string and are parsed as such.

See L<perlpod> for a better explanation of POD.


=head2 Literals

Deck supports the following data literals:

=head3 Numbers

Deck currently only implements a single Number type but there are
multiple literal forms.  They are:

	12345			# Decimal integer
	0456			# Also decimal--leading zeroes are ignored
	-123.456		# Negative float
	0xDEADBEEF		# Hex literal
	0b10101010		# Binary literal

Note that there is no octal form.  Unlike most C-like languages, a
leading zero in an integer literal does not indicate an octal
constant.

In addition, numeric literals may contain underscores (C<_>).  These
are ignored by the parser and so can be used to make your numbers more
readable:

	1_000_000		# One. Million. Dollars.

The underscore can appear anywhere in a number except for the
beginning:

	_3.14159		# WRONG!

This is needed to distinguish between numbers and symbols.


=head3 Strings

Deck has two kinds of strings: single-quoted strings and double-quoted
strings.  Both evaluate to the same kind of internal object but the
quote determines how they are parsed.

Both kinds of strings can be spread across multiple lines.

=head4 Single-Quoted Strings

Single-quoted strings are delimited by one or more single quote
characters (C<'>).  The text inside a single-quoted string is not
altered in any way.  It is stored literally without any kind of
escaping or interpolation:

	'Hello, world!'

Because quotes are likely to appear in the text with no way to escape
them, you can use a series of quotes as the delimiter instead of a
single quote:

	'''I don't think this will be a problem. Nor will "''" be.'''

Note that the delimiter B<must> have an B<odd> number of quote
characters.  Otherwise, it will look like an empty string (i.e. an
odd-number-sized delimiter followed by the closing delimiter.):

	''''Hello, world!''''			# WRONG!

	''''''							# Empty string

As a special case, any even number of single quotes is parsed as an
empty string.


=head4 Double-Quoted Strings

Double-quoted strings allow interpolation and escaping.  As in Perl
and C-family languages, the backslash character is used as the escape:

	"She said, \"That's what he said!\""

In addition, Deck implements a subset of Perl's escape sequences:

	\t		tab
	\n		newline
	\r		return
	\a		bell
	\f		form feed

For example:

	"line 1\nline 2\nline 3\n"

The backslash also escapes the other special characters:

	\$		Dollar sign (C<$>)
	\@		At sign (C<@>)
	\\		backslash (C</>)

For example:

	"\\Win \$\$\$\$\$ \@ my online casino!\\"

The C<$> and C<@> require some special attention.

Deck provides something like Perl-style variable interpolation.  If a
string contains a dollar sign (C<$>) followed by a name (and possibly
bracketted by curly brackets (C<{> and C<}>)), it will be replaced by
the value of the variable's printable form:

	x = "foo"
	puts "$x $x"				# "foo foo"
	puts "${x}bar"				# "foobar"

Similarly, an at-sign (C<@>) followed by the name of a list will
expand to the printable form of each element in the list separated by a
single space.  If the variable is not a list, it is expanded in the
same way as the C<$> for above:

	var x = :["foo" "bar" "quux"]
	puts "@x"					# "foo bar quux"
	x = 42
	puts "$x"					# "42"

Note that C<@> expansion only works for items of the type List.
Datatypes that mimic a List sufficiently well do not get expanded like
one.  However, this may change in a future release.

B<Beware:> Double-quoted strings are sometimes converted into more
complex expressions by the parser.  This can react badly with certain
other constructs to put a non-string where a string is expected.  For
example, if a procedure contains this docstring:

	proc foo {x} {
		"do the foo thing"
		...
	}

everything will be fine.  However, if you add an interpolation:

	proc foo {x} {
		"do the foo thing to $x"
		...
	}

what you're actually doing is this:

	proc foo {x} {
		[_::mkstr "do the foo thing to " x]
		...
	}

which is not only not a docstring but will attempt to call a string as
a function.

So remember: a double-quoted string is a true string if an only if it
does not contain an unescaped C<@> or C<$>.

Note: Deck currently has two printable forms, one from the C<printable>
attribute and the other coming from within.  String interpolation
currently uses the internal (wrong) one.  This Will Be Fixed.


=head2 Delimiters

Deck parses the following characters as special delimiters:


=over

=item 1) C<{> and C<}>, the curly brackets

=item 2) C<(> and C<)>, the round brackets

=item 3) C<[> and C<]>, the square brackets

=item 4) C<:>, the quote delimiter

=back

The first three items are the parentheses Deck supports.

The colon (C<:>) is used to quote (i.e. delay evaluation) of the thing
following it.  See L<Quoting> below.

=head2 Symbols

Symbols (aka words, aka names) are generally used as the names of
variables and constants.  There are two forms of symbols:

Textual symbols take the same form as most modern programming
languages' variables: an alphabetic character or the underscore (C<_>)
followed by zero or more "word" characters (i.e. alphanumerics or
underscore).  Examples:

	foo
	_foo42
	this_is_a_variable
	_45			# Tricky: a variable, NOT a number

Operators consist of one or more of any of the following "operator"
characters:

	C<->, C<.>, C<|>, C<!>, C<@>, C<$>, C<%>, C<^>, C<&>, C<+>, C<=>,
	C<?>,  C<E<lt>>, C<E<gt>>, C</>

For example:

	a + b

Operators may be prefixed by the backslash (C<\>).  This does not
change the symbol but sometimes provides a hint to the parse (see
B<Expressions> below).  For example:

	++ == \++			# This expression is true--they are the same symbol


=head2 Lists

Lists consist of zero or more items surrounded by square brackets
(C<[> and C<]>) and separated by whitespace.  They will nearly always
need to be preceded by the quote operator (C<:>) to keep them from
being treated as prefix expressions:

	:[1 "two" 3]			# Simple list
	:[]						# Empty list
	:["foo" "bar" [1 2 3]]	# Nested list

Symbols in lists do not need to be quoted:

	:[+ a b]

Sublists may also be in infix form.

	:[+ a (b & c)]			# Nested list with infix sublist

Note that there are a few special cases.  These are described in
L<Syntactic Sugar> below.

(As an aside, Lisp/Scheme hackers should be aware that the underlying
data structure of a Deck list is an array (aka a vector), B<not> a
linked list of CONS cells.  This is explained in more detail below.)


=head2 Expressions

Deck expressions ultimately take the form of Lisp-style prefix
expressions but the parser will also accept several more readable
forms and convert them into simple prefix expressions.


=head3 Quoting

The colon (C<:>) is Deck's quote symbol.  It is roughly the same as
the single quote (C<'>) in Scheme and Common Lisp.  A quoted
expression is any Deck expression following a quote:

	:42
	:[1 2 3]
	:foo

The quote prevents the thing from following it from being evaluated.
Instead, the result of a quote expression is the thing being quoted.
A quoted list returns the list itself:

	:[foo bar quux]

The unquoted list

	[foo bar quux]

would attempt to look up C<foo>, C<bar> and C<quux>, then call C<foo>
with the other values as arguments.

In the same way, quoting a symbol returns the symbol instead of its
value:

	:foo		# symbol :foo
	foo			# value of variable 'foo'

Other literals (single-quoted strings and numbers) yield themselves
when quoted.  Double-quoted strings yield either the string (if
there's no interpolation) or the quoted interpolation expression.

The various expression transformations that happen below (i.e. infix
expressions, LoLs and prefix syntactic sugar) are all done before the
expression is quoted.  In other words, quoting does not prevent those
transformations.

Note that the quote is a syntactic structure rather than a function.
The parser creates a quote expression when it sees the colon.  It does
not attempt to look up the value of the variable C<:> and call it as a
function.

The quote and the next expression together make up a single
expression.  This has higher precedence than anything else except for
parentheses.


=head3 Prefix Expressions

Deck prefix expressions are simple unquoted lists.  Each item in the
list is first recursively evaluated from left to right.  The first
expression in the list is expected to evaluate to a callable
function.  This function is called with the remaining items passed to
it as arguments:

	[+ 1 3]									# Simple example
	[[getHook :panic] "Oh no!"]				# Complex example
	
The semantics of this are explained in more detail below.

=head4 Syntactic Sugar

As a special exception to the list parsing rules, the following
symbols are always treated as infix expressions:

	C<=E<gt>>, C<.>
	C<-E<gt>>

The first two have the same precedence and the third has lower
precedence.

For any of the above operators, the sequence C<*expr1* *op* *expr2*> is
automatically treated as a parenthesized infix expression and becomes
C<[*op* *expr1* *expr2*]>.

So,

	[foo b.c]				becomes		[foo [. b c]]
	[x->y 42]				becomes		[[-> x y] 42]
	[bar x => y]			becomes		[bar [=> x y]]

It is an error to start or end an infix expression with one of these
operators:

	[-> a b]			# WRONG!

This auto-infix behaviour can be disabled by prefixing the operator
with a backslash (C<\>) character.  This does not alter the meaning of
the token but will disable the syntactic sugar:

	[foo b \. c]
	[x \-> y 42]
	[bar x \=> y]
	[\-> a b]


The C<=E<gt>> is bound to a macro that creates closures.  The C<.>
operator is used to access object attributes and the C<-E<gt>>
operator is used to look up methods in objects.


=head3 Infix Expressions

Any Deck expression surround by parentheses (aka round brackets, C<(>
and C<)>) is parsed as an infix expression.  The operator precedence
in decreasing order are as follows:

		. @ =>
		->
		**
		* / // %
		+ -
		<< >> >>> <<<
		== === != !== < > <= >= <=>
		&
		| ^
		&&
		||
		(user operators)			  
		=

All operators are left-associative except for C<=>.

Any other sequence of operator characters is also valid as an infix
operator but will have second-lowest precedence:

	(a !!! 2)			# does whatever !!! is defined to do

Like the syntactic sugar above, infix expressions are just another
syntactic form for basic Deck expressions.  The parser immediately
converts infix expressions to the equivalent prefix expression.  This
is true even if the expression is quoted:

	:(a + b * c)		# Yields [+ a [* b c]]

Infix expressions need to have an odd number of items with unescaped
operators in all of the even-numbered positions:

	(c / d & f)			# Right
	(c \+ d)			# WRONG!!!
	(c d e)				# WRONG!!!

The odd-numbered items may also be operators:

	(addOp = +)

(But be warned that this will not work in a LoL line.)

As a special case, a one-item infix expression is equivalent to just
the item:

	(a) === a
	:(a) === a
	

=head4 Negation

The C<-> operator with one argument negates that argument.  In this
case, it must be a B<prefix> expression.  There is no infix negation.
However, numeric constants may begin with a C<-> to indicate that they
are negative and those may be used in an infix expression.

Specifically:

	(a + -3)			# Correct. -3 is one token.
	(a + [- b])			# Correct. Infix negate on b
	(a + [neg b])		# Correct.
	(a + -b)			# ERROR
	(a + (-b))			# ERROR


=head3 LoLs

LoLs (Line-oriented Lists or Lists of Lists) are another form of Deck
expression.  Each LoL is delimited by braces (C<{> and C<}>) and is
immediately converted into a quoted list containing zero or more other
lists.

LoLs use line boundaries instead of brackets as the delimiters of
their sublists.  Specifically, a LoL line starts at	the end of the
previous LoL line (or the start of the LoL if this is the first line)
and ends at the following line-end (or the end of the LoL if this is
the last item) in which all brackets opened in this line have been
B<closed>.

Examples:

	{
		line 1					# First Entry

		line 2 {				# Second entry
			continuing...		# Second entry continued
		} and done!				# Second entry finished

		line 3 [1 2 3			# Third entry starts
			4 3]				# Third entry ends
	}

LoL lines are logical lines (as described above) and so are subject to
C<;> and C<\>.  In addition, comments are ignored as are empty lines
(i.e. lines containing no non-whitespace characters):

	{							# Empty line.  Ignored
		line 1 \				# Item 1 starts
		continued				#  ...and continues

		line 2 ; line 3; line 4	# Next three items
	}	

Deck source files are implicitly LoLs, as is the interactive command
prompt.  They differ from ordinary functions a little in that each
toplevel line is evaluated immediately before the next line is read.

Because the list delimiter is implied in a LoL, it is not clear
whether a LoL line is treated as an infix expression or as a prefix
expression.  The answer is, it depends.

The parser examines each LoL line and treats it as infix if it looks
infix or as prefix if it looks prefix.  If it can't decide, it is an
error.

Informally, LoL line looks infix if it is an assignment to a simple
variable, a sequence or an object attribute OR if it consists of a
series of terms divided by boolean AND (C<&&>) and OR (C<||>)
operators.

Otherwise, it is considered a prefix expression.  In the latter case,
there should be no unescaped operators in the expression (with C<var>
and C<const> expressions being the exception).

Here are some examples:

	{

		a = 42								# infix

		load "hello"						# prefix

		[load "hello"] || [die "error!"]	# infix

		obj.status = 42						# infix

		array@n = x + 5						# infix

	}

In addition, the 'var' and 'const' keywords are a wierd special case
in that they are infix expressions but allow the C<=> word unescaped
and will reparse some of their arguments as infix expressions:

	{

		var a = 42							# special case prefix

		const {x = 2+z; y = x + 1}			# prefix

		var a = x + y * 11;					# prefix but reparsed later

	}

Expressions that look like you made a mistake are usually considered
errors.  Specifically, prefix expressions (other than var/const) are
not allowed to contain unescaped operators:

	{

		a = b + + c				# Error!

		a = n + 1 +				# Error!

		a \= b \+ \+ c			# Prefix (calls a with arguments)

	}

Escaping operators allows you to tell the parser that yes, you know
what you're doing.

Here's the excruciatingly precise definition:

For a LoL line to be considered infix, it must:

=over

=item 1) Contain an odd number of elements and more than one element.

=item 2) Have only unescaped operators as the even-numbered elements.

=item 3) Have no unescaped operators as the odd-numbered elements.

=back

In addition, it must take one of the following forms:

=over

=item * C<name = ...>

A name that is not an unescaped operator followed by the word
C<=> and the rest of the expression.

=item * C<name @ <term> = ... >

A name that is not an unescaped operator, followed by the word C<@>,
followed by some term (often a number) followed by the word C<=> and
the rest of the expression.

=item * C<name1 . name2 = ... >

A name that is not an unescaped operator followed by C<.> followed by
another name that is also not an unescaped operator followed by C<=>
and the rest of the expression.

=item * C<term1> C<||/&&> C<term1> ...

An odd number of terms separated by one of the boolean operators C<||>
or C<&&>.

=back

For a line to be considered a prefix expression, it must either:

=over

=item * Contain B<no> unescaped operators

=item * Be a C<var> or C<const> expression with a C<=> as its second argument.

=back

Each non-empty, non-comment line must meet one set of requirements.
If it does not, it is an error.





=head1 Data

Deck has a number of built-in data types.  All of these are also
Classes (in the object-oriented-programming sense), making all data
objects OOP objects as well.

That being said, it is possible to (mostly) ignore this aspect of the
data objects and write procedural programs in Deck.

The inheritance heirarchy is as follows:

	Object
		Struct
		Class
		List
		Stringlike
			String
			Symbol
			ByteArray
		Number
		Nil
		Quote
		Macro
		Procedure
		Method
		MethodCall

Be aware that I reserve the right to reorganize the heirarchy as I see
fit, so it is not safe to depend on the inheritance structure.  It
B<is> safe (well, relatively) to assume that the methods will not be
removed from any objects' interfaces.

Classes are organized (mostly) according to their underlying
implementation.  Class C<Struct> represents the traditional Object
(methods and named fields) and will be the base class for most
traditional OOP.  (All of it, actually--the current implementation
doesn't let you subclass anything except B<Struct> or one of its
subclasses.)

The usual object construction mechanism--the C<new> method and
function--only works on classes derived from C<Struct>.

=head2 Basic Types

=head3 List

Type List is the basic list type.  Lists are arrays (B<not> linked
lists) of references.  Class List implements the L<Sequence Protocol>
(as described below.)

Lists are created by the parser from list literals, via the C<list>
function and through the C<listSized> function.


=head3 String

Class C<String> is the Deck string type.  Instances hold text in some
internal encoding.

C<String> implements the L<Sequence Protocol>.  Each element in a
String is individually addressable.  However, Deck does not have a
separate Character type.  Instead, each element of a String is also a
String of length one.

Instances are created from literals by the parser and by the function
C<stringSized>.

Note: At some time in the future, Deck will support Unicode and will
do it well.  Unfortunately, that day is a long time coming and depends
on me learning a lot more about Unicode than I know now.  In the
meantime, Strings are just whatever 8-bit ASCII superset your terminal
displays.

All of this vague definition of String as text of some sort is here as
a sort of placeholder for that day.  In particular, you're not
supposed to assume that you can throw any arbitrary binary data into a
String.  That may work now but it won't in the future.  If you need to
deal with binary data, use ByteArray.  It's designed for that.


=head3 Symbol

C<Symbols> are used to represent names in Deck expressions.  They are
similar to Strings.  However, they are immutable.  In addition, the
system guarantees that each C<Symbol> is unique.  That is, there is
only ever one symbol containing a particular sequence of characters.

C<Symbol> implements the L<Sequence Protocol> except for the ability
to set elements.  Attempting to modify a C<Symbol> results in an
error.

Instances are created by the parser from literals and by the function
C<intern>.  The function C<unintern> returns the string containing the
same letters as the symbol.

Symbols and strings with the same characters are equal according to
C<op_Equals>.



=head3 ByteArray

A C<ByteArray> is an array of 8-bit bytes.  It is here to give you a
way to manipulate binary data.  It implements the L<Sequence
Protocol>.  Only integers between 0 and 255 may be stored in a
C<ByteArray>.

Instances are created by the function C<bytesSized>.


=head3 Number

C<Numbers> represent numbers.  Instances are created by the parser
from literals and by arithmetic operations.  Numbers are immutable.

Note: Number is just a wrapper around Perl numbers, which is not
really ideal.  Ideally, there should be several numeric classes with
arithmetic operations smart enough to convert between them as
necessary.  This will probably change in the future.

=head3 Nil

C<Nil> is the class of C<nil>, the undefined object.  C<nil> is the
only instance of class C<Nil>.  Uninitialized values are set to C<nil>
by default.

C<Nil> is a true object however and implements the basic set of
methods.  In particular, its implementation of attribute C<isNil>
returns true.

=head3 Object

Object is the abstract base class of all objects in Deck.  It cannot
be instantiated.

=head3 Class

Type C<Class> is the type of all Deck classes.  It implements the
method C<new> which (usually) creates a new instance of the class.  It
also implements methods and attributes that provide extra information
about the class.

Every object's class is available through the C<class> attribute
implemented by Object.

Instances are created via the 'class' and 'object' macros.

Note: Every class in Deck is an instance of Class.  That includes
Class itself, which is its own grandpa.



=head2 Obscure Types

The following types are visible but are not commonly used.

=head3 Quote

A Quote contains one other object which may be read.  It exists solely
to indicate to the compiler that the wrapped object should not be
immediately evaluated.  You will only ever need it if you are
constructing code to be compiled.

Instances are created by the parser from the quote symbol (C<:>) (but
that will almost never reach you) and by the built-in function
C<quote>.  Note that the function C<quote> does not have any effect on
the evaluation of its arguments.


=head3 Macro, Procedure, Method

These are the types of various types of procedure.  The first two can
be invoked as part of an expression.  However, there is nothing useful
you can do with the objects other than that.

=head3 MethodCall 

A C<MethodCall> represents a method lookup on a specific object.  It
is callable.


=head3 Stringlike	

C<Stringlike> is the abstract base class for some types that contain
sequences of binary data.  It cannot be instantiated.


=head2 Struct

Type C<Struct> is the abstract base class for all structured objects.
Structured objects are objects containing zero or more named instance
variables--that is, objects as implemented by most object systems and
programming languages.

This is described in L<Objects> below.


=head2 Booleans

Deck does not have a dedicated Boolean type.  Instead, each object is
either true or false.

The following objects are false:

	0						(the Number 0)
	''						(any empty String)
	:[]						(any empty List)
	[intern '']				(the empty Symbol)
	[bytesSized 0]	        (any empty ByteArray)
	nil
	
In addition, any object whose C<isTrue> attribute yields C<nil> is
false.  Implementations of C<isTrue> should never return a different
value if the object has not changed.

Deck defines two constants, C<true> and C<false> that refer to the
"canonical" boolean values.  These are the values that most boolean
operators return.

C<true> is defined to be 1 and C<false> is defined to be C<nil>.
	
Note: 0 may be redefined as a true value at some later point.  Be
warned.


=head3 Stupid Boolean Tricks

Deck provides two short-circuited boolean operators, C<&&> (logical
and) and C<||> (logical or).  Because of the short-circuiting
behaviour, they can be used as control structures.

For example, here's a common idiom stolen from Perl:

	[doThing arg1 arg2] || [die "doThing failed."]

C<doThing> returns false on error and true on success.  As a result,
the C<die> expression is only called if C<doThing> fails.

The other interesting thing about these operators is that their result
is the value of the last expression evaluated.  You can leverage this
to do all kinds of useful conditional assignments:

	x = x || ""						# Ensure that x is initialized

	x = [cacheLookup] && [recalc]	# Recalculate if cache lookup fails
	
	y = (x > 5) && x || 5			# y = maximum of x and 5






=head1 Procedures

Deck procedures are opaque objects that can be called with optional
arguments and that return a value that may be ignored.  They are
created from one or more lists of expressions by a compiler which gets
invoked via various macros.  The underlying compiler code is
implementation-defined.

Note that in addition to procedures (a term with includes closures and
methods here), Deck provides two other callable types: C<Continuation>
and C<MethodCall>.  Both are discussed below.


=head2 Expression Evaluation

A Deck procedure body consist of a list containing zero or more other
lists.  Each of these sublists is an expression.  When invoked, the
procedure evaluates these expressions from start to finish:

	:[
		[fn1 1 2]		# First expression
		[fn2 3 4]		# Second expression
	]

Each expression must be a list of at least one element.  (Unlike
Scheme, you may not use a literal or variable as an expression.)

Expressions are evaluated as follows:

1) Each element is evaluated starting with the leftmost element (at
index 0) and working rightward (with increasing index values).  If the
element is an expression, it is recursively evaluated; if it is a
variable, its value is looked up.

2) The value off the first element in the list is assumed to be a
procedure (or more specifically, a callable--it is a runtime error if
it isn't) and it is called.  The values of the remaining elements are
passed to as actual arguments to the procedure call.

(Note that this explanation assumes that all macros have already been
expanded.) 

=head3 Variables and Constants

The one exception to the execution model discribed above is the
concept of variable declaration.  The word C<var> declares (and
optionally initializes) one or more variables in the current scope.
For example:

	proc {x} {
		puts x

		var y = x + 1
		puts y
	}

Notice that C<var> appears later in the function body.

Specifically, a C<var> declaration makes the compiler do three things:

=over

=item 1) Create the required variable(s) at the start of the procedure
         and initialize it to nil.

=item 2) Ensure that there is no use of the variable before the C<var>
         statement.

=item 3) Place the initializer (if present) at the site of the C<var>
         statement.

=back

The reason for this bit of wierdness is that final blocks make it
possible to access a variable before it is officially defined.  This
way, the variable will always exist, even if it's just C<nil>.

(Note: the current implementation doesn't yet do this.  Instead,
variables are declared by the 'var' statement.  This can result in
runtime undeclared variable errors.)


=head3 Assignment




=head2 Toplevels

=head2 Procs

=head2 Closures

=head3 =>

=head2 Final Blocks

=head2 Continuations


=head2 perlproc



=head1 Macros

=head2 Proper Macros

=head2 MProcs

=head3 MProc Syntax



=head1 Objects

=head2 The Metaclass System

=head2 Method Lookup Semantics

=head3 MethodCall

=head2 Basic Classes and Struct

=head2 Defining Classes

=head3 The 'class' macro

=head3 Methods

=head4 Private methods

=head4 op_*

=head3 Fields and Attributes

=head3 The 'object' macro

=head2 The Sequence Protocol




=head1 Namespaces

=head2 Defining Modules

=head3 Private Names

=head2 Importing Modules

=head2 Local vs Qualified names

=head2 Default Namespaces

=head2 Reserved Namespaces


=head1 The Perl Interface

=head2 PerlObj

C<PerlObj> is an implementation-specific type.  The current
implementation of Deck is in Perl and so a PerlObj is used to pass
information to code written in Perl and running on the underlying Perl
interpreter.

You may get a C<PerlObj> back from Perl code.  You can do nothing with
it in Deck except hand it back to a C<perlproc>.

(On the Perl side of things, a PerlObj is simply a blessed array ref
to a 1-element array containing some Perl object.  You create one by
returning C<LL::PerlObj->new($MY_PERL_OBJECT)> from a C<perlproc>.
The wrapping will let it return unmolested.  Passing a C<PerlObj> to a
C<perlproc> will strip off the wrapping automatically.)

=head2 perlproc

=head2 perluse



=head1 Bugs


