
=pod

This module provides a first attempt at file I/O.

=cut

package IO


# Interface to Perl file support:
perluse IO::File

perlproc _newfh {path mode} '''
    my $fh = IO::File->new($path, $mode);
    return $fh unless $fh;
    $fh->binmode(":raw");
    return $fh;
'''

perlproc _closefh {fh} '''
    $fh->close();
    return;
'''

perlproc _eof {fh} '''return $fh->eof();'''

perlproc _getline {fh eol} '''
    local $/ = $eol;
    my $line = <$fh>;
    return $line;
'''

perlproc _read {fh len} '''
	my $buf = "";
	my $count = $fh->read($buf, $len);
	return undef unless defined($count);

	return $buf;	
'''

perlproc _binread {fh len} '''
	my $buf = "";
	my $count = $fh->read($buf, $len);
	return undef unless defined($count);

    return LL::ByteArray->newContaining(\$buf);
'''


perlproc _errmsg {} '''return "$!";'''
perlproc _put  {fh str} '''return $fh->print($str);'''

perlproc _seek {fh pos whence} '''return $fh->seek($pos, $whence);'''
perlproc _tell {fh} '''return $fh->tell();'''



const _FILEMODES = :[ [read "<"]
					  [write ">"]
					  [readwrite "+<"] ]

const {
	SEEK_SET = 0
	SEEK_CUR = 1
	SEEK_END = 2
};
			  

class FileHandle {
	readable errorException
	public eol

	var fh
	var mode
	var filename

	method _init {name modeSymbol exception} {
		errorException = exception
		self->_exceptionSanityCheck

		eol = [chr 10]		# The UNIX default

		mode = modeSymbol
		self->_checkMode

		filename = name
		self->_openFh
	}

	method _openFh {} {
		fh = [_newfh filename [self->_modeStr]]
		fh || [self->_throw "Unable to open file '$filename'." :openError]
	}

	method _checkMode {} {
		for legalMode in _FILEMODES {
			(legalMode@0 == mode) && [return]
		}

		self->_throw "Invalid file mode: '$mode'" :badArg mode		
	}

	method _modeStr {} {
		for modePair in _FILEMODES {
			if (modePair@0 == mode) {return (modePair@1)}
		}
		die "Internal error: Illegal mode symbol: $mode"
	}

	method _sanity {op} {
		(op == :read && [not self.canRead]) && \
			[self->_throw "FileHandle not open for reading." :modeErr]

		(op == :write && [not self.canWrite]) && \
			[self->_throw "FileHandle not open for writing." :modeErr]

		fh || [self->_throw "Attempted operation on closed filehandle."
			   :closedFhErr]
	}

	method _throw {msg op args} {
		apply (errorException->throw) [concat [list msg op] args]
	}

	method close {} {
		fh && [_closefh fh]
		fh = nil
	}

	method exception_set {e} {
		"Get/set the error exception.  This is the exception that gets thrown
         if there is an I/O error."

		errorException = e
		self->_exceptionSanityCheck
	}

	method _exceptionSanityCheck {} {
		[errorException.class->can :throw] || \
			[die "Attempted to store non-exception as FileHandle exception."]
	}


	method canRead_get {} {
		return (mode != :write)
	}

	method canWrite_get {} {
		return (mode != :read)
	}

	method eof_get {} {
		fh || [return false]
		return [_eof fh].isTrue
	}

	method getLine {} {
		self->_sanity :read

		(eol.class == String && eol != "") \
			|| [die "Illegal line separator: '$eol'."]

		return [_getline fh eol]
	}

	method slurp {} {
		self->_sanity :read
		return [_getline fh nil]
	}

	method getChar {} {
		return [self->getChars 1]
	}

	method getChars {count} {
		self->_sanity :read

		var line = [_read fh count]
		if (line == nil) {
			var errmsg = [_errmsg]
			self->_throw "IO Error: $errmsg" :ioErr
		}

		return line
	}


	method put {string} {
		self->_sanity :write

		[_put fh string] || \
			[self->_throw "Error writing string to '$filename'."  :ioError]
	}

	method puts {args} {
		for obj in args {
			self->put obj.printable
		}
		self->put eol
	}


	method write {bytes} {
		self->_sanity :write

		(bytes.class == ByteArray) || \
			[die "FileHandle->write argument must be ByteArray."]

		[_put fh bytes] || \
			[self->_throw "Error writing ByteArray to '$filename'."  :ioError]
	}

	method read {numBytes} {
		self->_sanity :read

		var line = [_binread fh numBytes]

		if (line == nil) {
			var errmsg = [_errmsg]
			self->_throw "IO Error: $errmsg" :ioErr
		}

		return line
	}

	method pos_get {} {
		fh || [return -1]
		return [_tell fh]		
	}

	method isOpen_get {} {
		return [fh.isTrue]
	}

	method seek {pos whence} {
		self->_sanity :seek
		[_seek fh pos whence] || \
			[self->_throw "Seek error." :seekError]
	}
}

