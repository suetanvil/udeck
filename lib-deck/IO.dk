
=pod

This module provides a first attempt at file I/O.

=cut

package IO


# Interface to Perl file support:
perluse IO::File

perlproc _newfh {path mode} '''
    my $fh = IO::File->new($path, $mode);
    return $fh unless $fh;
    $fh->binmode(":raw");
    return $fh;
'''

perlproc _closefh {fh} '''
    $fh->close();
    return;
'''

perlproc _eof {fh} '''return $fh->eof();'''

perlproc _getline {fh eol} '''
    local $/ = $eol;
    my $line = <$fh>;
    return $line;
'''

perlproc _read {fh len} '''
	my $buf = "";
	my $count = $fh->read($buf, $len);
	return undef unless defined($count);

	return $buf;	
'''

perlproc _binread {fh len} '''
	my $buf = "";
	my $count = $fh->read($buf, $len);
	return undef unless defined($count);

    return LL::ByteArray->newContaining(\$buf);
'''


perlproc _errmsg {} '''return "$!";'''
perlproc _put  {fh str} '''return $fh->print($str);'''

perlproc _seek {fh pos whence} '''return $fh->seek($pos, $whence);'''
perlproc _tell {fh} '''return $fh->tell();'''



const _FILEMODES = :[ [read "<"]
					  [write ">"]
					  [readwrite "+<"] ]

const {
	SEEK_SET = 0
	SEEK_CUR = 1
	SEEK_END = 2
};


class FileHandle {
	"FileHandle represents access to a file on disk.  The filename is passed
     to the initializer along with a symbol indicating the mode (C<:read>,
     C<:write> or C<:readwrite>) and an Exception to throw if an error
     occurs.

     The exception is accessible through the field C<errorException> and may
     be replaced at any time.

     FileHandle can treat its file as binary or text or some combination of
     both, depending on how it is accessed.  Methods C<read> and C<write> will
     read or write the contents as ByteArray instances while C<getChar>,
     C<getChars>, C<getLine>, C<put>, C<puts> and C<slurp> read and write
     strings.  Note that although it is currently possible to store any series
     of bytes in a Deck string, this may not be the case in the future.  If
     you need to manipulate binary data, use C<ByteArrays>.

     C<FileHandles> need to be closed when they are no longer needed.  There
     is no finalization mechanism (yet) to close them when they are
     garbage-collected.

     (To do: Exceptions need to be made optional.)"


	readable errorException
	public eol

	var fh
	var mode
	var filename

	method _init {name modeSymbol exception} {
		errorException = exception
		self->_exceptionSanityCheck

		eol = [chr 10]		# The UNIX default

		mode = modeSymbol
		self->_checkMode

		filename = name
		self->_openFh
	}

	method _openFh {} {
		fh = [_newfh filename [self->_modeStr]]
		fh || [self->_throw "Unable to open file '$filename'." :openError]
	}

	method _checkMode {} {
		for legalMode in _FILEMODES {
			(legalMode@0 == mode) && [return]
		}

		self->_throw "Invalid file mode: '$mode'" :badArg mode		
	}

	method _modeStr {} {
		for modePair in _FILEMODES {
			if (modePair@0 == mode) {return (modePair@1)}
		}
		die "Internal error: Illegal mode symbol: $mode"
	}

	method _sanity {op} {
		(op == :read && [not self.canRead]) && \
			[self->_throw "FileHandle not open for reading." :modeErr]

		(op == :write && [not self.canWrite]) && \
			[self->_throw "FileHandle not open for writing." :modeErr]

		fh || [self->_throw "Attempted operation on closed filehandle."
			   :closedFhErr]
	}

	method _throw {msg op args} {
		apply (errorException->throw) [concat [list msg op] args]
	}

	method close {} {
		"Close the underlying system file handle associated with this
         file.  After C<close> has been called, this object should no
         longer be used."
		fh && [_closefh fh]
		fh = nil
	}

	method exception_set {e} {
		"Get/set the error exception.  This is the exception that gets thrown
         if there is an I/O error."

		errorException = e
		self->_exceptionSanityCheck
	}

	method _exceptionSanityCheck {} {
		[errorException.class->can :throw] || \
			[die "Attempted to store non-exception as FileHandle exception."]
	}


	method canRead_get {} {
		"Test if this C<FileHandle> is readable."
		return (mode != :write)
	}

	method canWrite_get {} {
		"Test if this C<FileHandle> is writeable."
		return (mode != :read)
	}

	method eof_get {} {
		"Test if this file handle is at the end of the file."
		fh || [return false]
		return [_eof fh].isTrue
	}

	method getLine {} {
		"Read one line of text and return it as a String.  The line delimiter
         is determined by the attribute C<eol>.  It defaults to the UNIX
         newline (0x0a).  The delimiter is not stripped from the string.  If
         the C<FileHandle> is at the end of the file, C<getLine> returns an
         empty string."
		self->_sanity :read

		(eol.class == String && eol != "") \
			|| [die "Illegal line separator: '$eol'."]

		var line = [_getline fh eol]
		(line == nil) && [return ""]
		return line
	}

	method slurp {} {
		"Read the remaining contents of this file and return them as a
         string.  This can be an empty string if the file position is already
         at the end of the file."
		self->_sanity :read
		return [_getline fh nil]
	}

	method getChar {} {
		"Read a single character from this file and return it as a string."
		return [self->getChars 1]
	}

	method getChars {count} {
		"Read C<count> characters from the current input file and return them
         in a string.  If C<count> is more than the number of characters to
         the end of the file, the remaining characters are returned.  This is
         true even if the C<FileHandle> is already at the end of the file.  In
         that case, the return value is an empty string."
		self->_sanity :read

		var line = [_read fh count]
		if (line == nil) {
			var errmsg = [_errmsg]
			self->_throw "IO Error: $errmsg" :ioErr
		}

		return line
	}


	method put {string} {
		"Writes C<string> at the current file position."
		self->_sanity :write

		[_put fh string] || \
			[self->_throw "Error writing string to '$filename'."  :ioError]
	}

	method puts {args} {
		"Writes the printable form of each argument to the file starting from
         the current position, then appends a newline (as defined by C<eol>).
         Analogous to the C<puts> function."
		for obj in args {
			self->put obj.printable
		}
		self->put eol
	}


	method write {bytes} {
		"Writes the bytes in C<bytes>, a ByteArray, to the current file at
         the current position."
		self->_sanity :write

		(bytes.class == ByteArray) || \
			[die "FileHandle->write argument must be ByteArray."]

		[_put fh bytes] || \
			[self->_throw "Error writing ByteArray to '$filename'."  :ioError]
	}

	method read {numBytes} {
		"Reads C<numBytes> bytes from the file starting at the current
         position, then returns them in a ByteArray.  If C<numBytes> is more
         than the number of bytes remaining in the file, only the number of
         remaining bytes are read.  If the current position is at the end of
         the file, returns an empty ByteArray."
		self->_sanity :read

		var line = [_binread fh numBytes]

		if (line == nil) {
			var errmsg = [_errmsg]
			self->_throw "IO Error: $errmsg" :ioErr
		}

		return line
	}

	method pos_get {} {
		"Returns the position B<in bytes> of this C<FileHandle> relative to the
         start of the file."

		fh || [return -1]
		return [_tell fh]		
	}

	method seek {pos whence} {
		"Sets the position of this C<FileHandle> to C<pos>.  C<whence>
         controls how C<pos> is used: C<SEEK_SET> sets the position to C<pos>,
         C<SEEK_CUR> sets it to C<pos> plus the current position and
         C<SEEK_END> sets it to C<pos> plus the end of the file (C<pos> is
         typically negative."
         
		self->_sanity :seek
		[_seek fh pos whence] || \
			[self->_throw "Seek error." :seekError]
	}

	method isOpen_get {} {
		"Test if this FileHandle is open.  If it has been closed (via
         C<close>), this attribute will return false; otherwise, it will
         return true.  Naturally, this attribute is safe to call on a closed
         C<FileHandle>."
		return [fh.isTrue]
	}
}

=pod xxx

mproc dofile {
	name
	mode
	strict sub [fh] fileBlock
	word catch [default :catch]
	strict sub [Error] catchBlock [default {}]
} {
	var fh = nil

	try {
		fh = [new FileHandle name mode Error]
		fileBlock fh
	} catch {
		catchBlock Error
	}

} {
	fh && [fh->close]
}


=cut