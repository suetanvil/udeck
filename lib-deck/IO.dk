
=pod

This module provides a first attempt at file I/O.

=cut

package IO


# Interface to Perl file support:
perluse IO::File

perlproc _newfh {path mode} '''
    my $fh = IO::File->new($path, $mode);
    return $fh unless $fh;
    $fh->binmode(":raw");
    return $fh;
'''

perlproc _closefh {fh} '''
    $fh->close();
    return;
'''

perlproc _eof {fh} '''return $fh->eof();'''

perlproc _getline {fh eol} '''
    local $/ = $eol;
    my $line = <$fh>
    return $line;
'''


const _FILEMODES = :[ [read "<"]
					  [write ">"]
					  [readwrite "+<"] ]
			  

class FileHandle {
	readable errorException
	public eol

	var fh
	var mode

	method _init {name modeSymbol exception} {
		errorException = exception
		self->_exceptionSanityCheck

		eol = "\x0A"

		mode = modeSymbol
		self->_checkMode

		self->_openFh name
	}

	method _openFh {name} {
		fh = _newfh name [self->_modeStr]
		fh || [exception->throw "Unable to open file '$file'." :openError]
	}

	method _checkMode {} {
		for legalMode in _FILEMODES {
			(legalMode@0 == mode) && [return]
		}

		errorException->throw "Invalid file mode: '$mode'" :badArg mode		
	}

	method _modeStr {} {
		for modePair in _FILEMODES {
			(modePair@0 == mode) || [return (modePair@1)]
		}
		die "Internal error: Illegal mode symbol: $mode"
	}
	

	method close {} {
		fh && [_closefh fh]
		fh = nil
	}

	method exception_set {e} {
		"Get/set the error exception.  This is the exception that gets thrown
         if there is an I/O error."

		errorException = e
		self->_exceptionSanityCheck
	}

	method _exceptionSanityCheck {} {
		[errorException.class->can :throw] || \
			[die "Attempted to store non-exception as FileHandle exception."]
	}


	method canRead_get {} {
		return (mode != :write)
	}

	method canWrite_get {} {
		return (mode != :read)
	}

	method eof_get {} {
		fh || [return false]
		return [_eof fh].isTrue
	}

	method getLine {} {
		self.eof && [return ""]

		(eol.class == String && eol != "") \
			|| [die "Illegal line separator: '$eol'."]

		return [_getline fh eol]
	}

	method slurp {} {
		self.eof && [return ""]

		return [_getline fh nil]
	}


	method getChar {} {
		return [self->getChars 1]
	}

	method getChars {count} {
	}


	method put {string} {

	}

	method puts {args} {
		for obj in args {
			self->put obj.printable
		}
		self->put "\n"
	}


	method write {bytes} {

	}

	method read {numBytes} {

	}


	method pos_get {} {
	}

	method seek {pos} {
	}



}

