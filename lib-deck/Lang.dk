# The Deck system library.  Contents are imported into module Lang
# after startup.

# no package declaration because this module has already been created.

var Version = '0.01';

const {
	true = 1
	false = nil
}

proc _seq_Equals
proc _write_seq
proc puts
proc slice

perlproc sprintf {fmt args} '''sprintf ($fmt, @args)'''

perlproc _str_lte {left right} '''return ($left lt $right || $left eq $right)'''




# Base class for all traditional structured objects
_class_ext Object {
	'''
	C<Object> is the root class.  All other classes in Deck are derived
	from Object.

	C<Object> is a pure abstract base class.  It cannot be instantiated.
	'''

	# This method is called when the object receives a message it does not
	# understand (i.e. there is no corresponding method implemented.)

	# Default behaviour is to exit with an error message.
	method doesNotUnderstand {name args} {
		die "Unknown method '$name' in class '" self.class.name "'"
	}


	# This is the message that each object receives when it is first
	# created. Its implementation is expected to initialize the new object.
	method init {args} {}

	method isNil_get {} {return nil}
	method op_Equals {other} {return (self === other)}

	method at {index} {die "Not indexable."}
	method atPut {index value} {die "Not indexable."}
	method size_get {} {die self.class " is not indexable."}
	method maker_get {} {
		'''
		Sequence protocol: return a function which will create a collection
		suitable for holding the contents of self and which takes one argument,
		a number specifying the size.  It defaults to C<listSized>.
		'''
		return listSized
	}

	method isIndexable_get {} {return nil}
	method last_get {} {return (self.size - 1)}

	method printable_get {} {
		var cl = self.class.name
		var a = [if ((cl@0).isVowel) {value "an"} {value "a"}]

		return "$a $cl"
	}

	# Copy protocol.
	method shallowCopy {} {die "Called abstract shallowCopy"}
	method copy {} {return [self->shallowCopy]}

	# Needed for test case
	method self_get {} {}

	# Comparison behaviour
	method op_Lt       {obj} {return (self <= obj && self != obj)}
	method op_Lte      {obj} {die "Called abstract op_Lte on " self.class.name}
	method op_Gt       {obj} {return [not (self <= obj)]}
	method op_Gte      {obj} {return (self > obj || self == obj)}

}

_class_ext Number {
	'''
	C<Number> is the class of all (built-in) number types in Deck.
	Instances are floating-point values.
	'''

	# Double-dispatch methods
	method op_Add      {obj} {return [obj->addNumber self]}
	method op_Sub      {obj} {return [obj->subNumber self]}
	method op_Mod      {obj} {return [obj->modNumber self]}
	method op_Mult     {obj} {return [obj->multNumber self]}
	method op_Div      {obj} {return [obj->divNumber self]}
	method op_DivTrunc {obj} {return [obj->divTruncNumber self]}
	method op_Lte      {obj} {return [obj->lteNumber self]}
	method op_Pow	   {obj} {return [obj->powNumber self]}
	method op_BitOr	   {obj} {return [obj->bitOrNumber self]}
	method op_BitXor   {obj} {return [obj->bitXorNumber self]}
	method op_BitAnd   {obj} {return [obj->bitAndNumber self]}

	# Optional comparisons.  Object already implements them but these
	# versions are (probably) faster.
	method op_Lt       {obj} {return [obj->ltNumber self]}
	method op_Gt       {obj} {return [obj->gtNumber self]}
	method op_Gte      {obj} {return [obj->gteNumber self]}

	method shallowCopy {} {return self}

	method printable_get {} {return "$self"}
}

_class_ext Nil {
	'''
	C<Nil> is the type of the object representing uninitialized variables.
	There is only one instance, the global constant C<nil>.  Unset variables
	are initialized to nil, as are empty lists.
	'''

	method isNil_get {} {return 1}
	method printable_get {} {return "nil"}

	method shallowCopy {} {return self}
}

_class_ext List {
	'''
	C<List> is the fundamental Deck list type.  Unlike most Lispish languages,
	Deck does not present its lists as linked lists of cells.  Instead, a
	Deck C<List> is an array (i.e. a "vector") of object references whose
	individual items can be accessed with the C<at> and C<atPut> methods
	(usually hidden by the C<@> operator).  The indexes start at zero and
	increase to the number of items minus one.

	This is different from most Lispish languages, where a list is implemented
	as a linked list of pairs of references (CONS cells).

	C<List> implements the sequence protocol: C<at>, C<atput>, C<size>,
	C<maker> C<isIndexable> returns true.
	'''


	method isIndexable_get {} {return 1}
	method printable_get {} {
		const MAX = 5
		(self.size < MAX + 3) && [return "[@{self}]"]

		var sublist = [listSized MAX]

		var index = 0
		while (index < MAX) {
			sublist@index = self@index
			index = index + 1
		}

		var last = self @ -1
		return "[@sublist .. $last]"
	}

	method op_Equals {obj} {return [_seq_Equals self obj]}

	method op_Add {otherSeq} {
		var result = [listSized (self.size + otherSeq.size)]
		_write_seq self otherSeq result
		return result
	}

}

_class_ext Stringlike {
	'''
	This is the abstract base class for several classes representing
	various sequences of binary or specially-encoded data.  It should
	not be used directly.
	'''

	method isIndexable_get {} {return 1}
}


perlproc _downcase {s} '''$s =~ y/A-Z/a-z/;return $s;'''
perlproc _isspace {s} '''return $s =~ /^\s+$/;'''

_class_ext String {
	'''
	C<String> instances contain human-readable text which can be
	printed to the console or stored in a file.  The class implements
	the sequence protocol but the objects stored or retrieved from a
	C<String> must themselves be strings of length 1.  

	Unlike many other languages, Deck does not have a character type.
	Instead, strings are encoded in some manner and it is best not to
	make assumptions about the details.  In particular, you should
	B<never> use a C<String> to hold arbitrary binary data as this
	will break when Deck switches to using UTF8.  Use C<ByteArray> for
	that.
	'''

	method isVowel_get {} {
		(self.size != 1) && [return false]

		var lc = self.lowercase

		for v in [list "a" "e" "i" "o" "u"] {
			if (lc == v) {
				return true
			}
		}
		return false
	}

	method isSpace_get {} {
		'''Test if C<self> is all whitespace.'''
		return [_isspace self]
	}

	method lowercase_get {} {return [_downcase self]}
	method printable_get {} {return "$self"}

	# op_Equals is implemented in Perl

	method op_Add {otherString} {
		var result = [stringSized (self.size + otherString.size)]
		_write_seq self otherString result
		return result
	}

	method op_Lte {other} {
		if (other.class == Symbol) {
			other = [unintern other]
		}

		(other.class == String) \
			|| [die "Comparing string with " other.class ]

		return [_str_lte self other]
	}

	method maker_get {} {return stringSized}
}


_class_ext Symbol {
	'''
	Symbols are mostly used to represent names in expressions.  They
	are similar to strings in that they contain human-readable text.  However,
	there are some notable differences:

	=over

	=item 1.

	Symbols are immutable.  C<atPut> will fail on one.

	=item 2.

	Symbols are unique.  There is only ever one symbol with a particular
	value.

	=back

	C<Symbol> implements the sequence protocol but as mentioned above, the
	C<atPut> method will fail.

	C<Symbols> can be converted to and from strings via the C<intern> and 
	C<unintern> functions.  Symbol constants are tokens beginning with the
	C<:> character, e.g. ":foo".
	'''

	method printable_get {} {return ":$self"}

	method op_Equals {obj} {
		(obj.class == String) && [return ("$self" == obj)]
		return (self === obj)
	}

	method op_Add {obj} {
		var result = [stringSized (self.size + obj.size)]
		_write_seq self obj result
		return result
	}

	method shallowCopy {} {return self}

	method op_Lte {other} {
		return ([unintern self] <= other)
	}

	method maker_get {} {return stringSized}  # symbols are immutable
}



_class_ext ByteArray {
	'''
	A C<ByteArray> is a sequence of 8-bit bytes.  Any sequence of bytes
	is allowed.

	C<ByteArray> implements the sequence protocol but will fail if you
	attempt to store a value in it that is not an integer between 0 and 255.
	'''
   	method printable_get {} {
		const MAXSIZE = 5
		var {count = MAXSIZE}

		var dotdot = " .. "
		var last = [sprintf "0x%02x" (self@ -1)]

		if (self.size < MAXSIZE + 3) {
			dotdot = ""
			last = ""
			count = self.size
		}

		var formatted = [listSized count]
		var index = 0
		while (index < count) {
			formatted@index = [sprintf "0x%02x" (self@index)]
			index = index + 1
		}

		return "[byteArray @formatted$dotdot$last]"
   	}

	method op_Equals {obj} {return [_seq_Equals self obj]}

	method op_Add {otherBArray} {
		var result = [bytesSized (self.size + otherBArray.size)]
		_write_seq self otherBArray result
		return result
	}

	method maker_get {} {return bytesSized}
}

_class_ext Struct {
	'''
	C<Struct> is the base class for all traditional classes.  A traditional
	class is a class whose data is stored in named fields.

	This is an abstract base class and cannot be instantiated.  All subclasses
	should implement the method C<init> to initialize the fields when an
	instance is created.

	C<Struct> subclasses are typically instantiated using the C<new> method or
	procedure.
	'''
}


_class_ext Class {
	'''
	All classes (i.e. types) in Deck are themselves objects and those objects
	are instances of type C<Class>.  This includes C<Class> itself.

	C<Class> serves two purposes: to provide information about the class and
	to create new instances via its C<new> method.
	'''

	method printable_get {} {
		var nm = self.name
		(nm.size == 0) && [return "a Class"]
		
		return "class $nm"
	}
}

_class_ext Quote {
	'''
	C<Quote> instances are used to represent quotation in Deck expressions.
	Each C<Quote> contains a single data value which may be accessed using
	the C<value> attribute.  The presence of the C<Quote> in an expression
	is used to indicate that the value it wraps should not be evaluated in
	the usual way.

	You will only ever need to use a C<Quote> when creating Deck expressions
	to be compiled later by the Deck compiler.
	'''

	method printable_get {} {
		var v = self.value
		return "[quote $v]"
	}

	method op_Equals {obj} {
		(self.class == obj.class) || [return false]
		return (self.value == obj.value)
	}

	method shallowCopy {} {
		return [quote self.value]
	}
}


_class_ext Macro {
	"C<Macro> is the class of all Deck macros."
	method shallowCopy {} {return self}
	method printable_get {} {return "<macro>"}
}

_class_ext Function {
	"C<Function> is the class of most Deck functions (procs, subs, etc)."
	method shallowCopy {} {return self}
	method printable_get {} {return "<function>"}
}

_class_ext Method {
	"C<Method> is the class of all Deck methods."
	method shallowCopy {} {return self}
	method printable_get {} {return "<method>"}
}

_class_ext MethodCall {
	'''
	C<MethodCall> is the class of all method call objects.  Method calls are
	callable objects that will call a specific method on a specific object,
	both of which are captured inside the C<MethodCall>.

	Instances of C<MethodCall> are the result of a call to C<getMethod> or
	C<getSuperMethod> (which are usually called by the macro C<-E<gt>>).
	'''
	method shallowCopy {} {return self}
	method printable_get {} {return "<method call>"}
}

_class_ext PerlObj {
	'''
	C<PerlObj> is a wrapper around some Perl data.  Perl functions created
	using C<perlproc> can return Perl data that has no meaningful
	representation inside Deck and these can then be passed to other Perl
	functions.

	For example, a Deck wrapper around a Perl library may use a C<PerlObj> to
	hold a reference to an instance of a class defined in the library.

	There is no way to modify a PerlObj in Deck.
	'''


	# method printable_get is written in perl
}


# Equality support.  This should really be part of a trait, but Deck
# doesn't implement them yet.
proc _seq_Equals {left right} {
	(left.class === right.class) || [return false]
	(left.size == right.size) || [return false]

	var index = 0
	while (index < left.size) {
		(left@index == right@index) || [return false]
		index = index + 1
	}

	return true
}


# Write the contents of src1 and src2 sequentially onto dest.  Assumes
# that dest is long enough and of the right type to hold the contents.
proc _write_seq {src1 src2 dest} {
	var index = 0
	for item in src1 {
		dest@index = item
		index = index + 1
	}

	for item in src2 {
		dest@index = item
		index = index + 1
	}
}


proc cmp {left right} {
	'''
	Compare C<left> and C<right> and return -1, 0 or 1 if C<left> is less than,
	equal to or greater than C<right>.
	'''
	(left == right)	&& [return 0]
	(left > right)	&& [return 1]
	return -1
}
const \<=> = cmp

# Return the absolute value of a number
proc abs {n} {
	"Return the absolute value of C<n>, a Number."
	if (n < 0) {
		return [-n]
	}
	return n
}

# The not-equal operator
proc \!= {left right} {
	"Return C<true> if C<left> and C<right> are not equal (C<==>)."
	return [not (left == right)]
}

proc size {aList} {return aList.size}
proc last {aList} {return aList.last}

proc typeof {obj} {return [intern obj.class.name]}

proc asList {seq} {
	'''
	Return a list containing the contents of C<seq>, an object that
	implements the list protocol.
	'''

	var result = [listSized seq.size]
	var index = 0
	for elem in seq {
		result@index = elem
		index = index + 1
	}

	return result
}


perlproc _perlsort {fn ls} '''
  $fn->checkFun(" in _sort perlfunc.");
  my $result = [sort {$fn->($a, $b)->perlForm()} @{$ls}];
  return $result;
'''

mproc sort {
	sub 2 ucmp
	seq
} {
	'''
	Return a copy of C<seq> with the elements sorted according to C<ucmp>.

	C<ucmp> should take two arguments and return -1, 0 or 1 depending on
	whether the first argument is less than, equal to or greater than the
	second argument.  (This is the same interface as C<cmp>).

	C<seq> is an object that implements the sequence protocol and the return
	value is constructed by the function returned by C<seq>'s C<maker>
	attribute.
	'''

	var sortList = seq
	if (sortList.class != List) {
		sortList = [asList sortList]
	}

	var resultList = [_perlsort [perlobj ucmp] [perlobj sortList]]

	(seq.class == List) && [return resultList]

	var result = [(seq.maker) seq.size]
	_write_seq resultList :[] result

	return result
}

mproc reduce {
	sub 1 filter
	seq
} {
	'''
	Apply function C<filter> to every element of sequence C<seq> and return
	another sequence containing only the elements on which C<filter> returned
	a true value.  The return value's type is compatible with C<seq>'s.
	'''

	var result = [(seq.maker) seq.size]
	var index = 0

	for elem in seq {
		if ([filter elem]) {
			result@index = elem
			index = index + 1
		}
	}

	return [slice result 0 (index - 1)]
}
			


# Insert spacer between all elements in aList
# proc withSpacer {aList spacer} {

# 	var rs = [size aList] * 2
# 	if ([size aList] % 2
# 	var result = [listSized 


# }



class Interval Struct {
	'''
	Instances of C<Interval> mimic a list containing a consecutive list of
	numbers as defined by the C<new> arguments C<startVal>, C<endVal> and
	C<incrVal>, all Numbers truncated to the nearest integer. C<startVal> is
	the first number, C<endVal> is the last (possibly approximated) and 
	C<incrVal> is the increment from one value to the next.

	The main purpose of C<Interval> is to provide a way to do a for/foreach
	loop over a series of integers without having to create an actual array
	of integers.  This allows you to do stuff like this:

	    C<for i in (1 .. 10000000) { ... }>

	instead of

	    C<var x = 0; while (x < 10000000) { ... ; x = x + 1 }>

	(The C<..> operator creates an C<Interval>.)

	C<Intervals> implement the sequence protocol but C<atPut> fails with
	an error.
	'''


	readable start
	var length
	var incr

	method op_Equals {other} {
		(other.class == self.class) || [return false]
		return (start == other.start && length == other.size)
	}

	method end_get {} {
		return (self @ (length - 1))
	}

	method _init {startVal endVal incrVal} {
		start = [int startVal]
		var end = [int endVal]
		incr = [int incrVal]

		length = ([abs (end - start)] + 1)
	}

	method isIndexable_get {} {return 1}
	method atPut {index value} {
		die "Attempted to write to read-only object."
	}

	method size_get {} {return length}

	method at {index} {
		if (index >= length) {
			die "Attempted to read past end of interval."
		}

		return (start + (index * incr))
	}

	method printable_get {} {
		var end = start + (length * incr) - 1

		var by = ""
		if ([abs incr] != 1) {
			by = " (by $incr)"
		}
 
		return "$start .. $end$by"
	}
}


# Produce a list of elements between start and end separated by 1
proc \.. {start end} {
	'''
	Create an C<Interval> for the range from C<start> to C<end> with an 
	increment of 1.
	'''

	var by = 1
	if (end < start) {
		by = -1
	}
	return [Interval->new start end by]
}
const range = \..


# Extract a sublist from aList
proc slice {seq start end} {

	if (end == nil || end > [last seq]) {
		end = seq.last
	}

	if (start > end || start > [last seq]) {
		return [(seq.maker) 0]
	}

	var range = (start .. end)
	var result = [(seq.maker) [size range]]
	var index = 0
	foreach n in range {
		result@index = seq@n
		index = index + 1
	}

	return result
}

# Concatenate all list-like arguments together.
proc concat {args} {
	var len = 0
	foreach l in args {
		len = len + [size l]
	}

	var result = [((args@0).maker) len]
	var pos = 0
	foreach l in args {
		foreach elem in l {
			result@pos = elem
			pos = pos + 1
		}
	}

	return result
}


perlproc _rand {} ''' return rand(1); '''

proc rand {max} {
	return (max * [_rand])
}

proc irand {max} {
	return [int [rand max]]
}


# Return a shuffled copy of seq
proc shuffled {origSeq} {
	var seq = [origSeq->shallowCopy]

	for index in (seq.last .. 1) {
		var pick = [rand (index - 1)]
		
		var tmp = seq@pick
		seq@pick = seq@index
		seq@index = tmp
	}

	return seq
}


perlproc _printstr {s} ''' print $s; '''

proc say {args} {
	for obj in args {
		_printstr obj.printable
	}
}

proc puts {args} {
	apply say args
	say "\n"
}



