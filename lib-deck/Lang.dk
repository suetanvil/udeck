# The Deck system library.  Contents are imported into module Lang
# after startup.

# no package declaration because this module has already been created.

var Version = '0.01';

const {
	true = 1
	false = nil
}

proc _seq_Equals
proc _write_seq
proc puts
proc slice

perlproc sprintf {fmt args} '''sprintf ($fmt, @args)'''

perlproc _str_lte {left right} '''return ($left lt $right || $left eq $right)'''




# Base class for all traditional structured objects
_class_ext Object {
	'''
	C<Object> is the root class.  All other classes in Deck are derived
	from Object.

	C<Object> is a pure abstract base class.  It cannot be instantiated.
	'''

	# Docs for builtin methods:
	mdoc class_get {} "Return the class of this object."
	mdoc isTrue_get{} "Return this object's truth value.  Somewhat magical."

	method doesNotUnderstand {name args} {
		'''
		This method is called when the object receives a message it does not
		understand (i.e. there is no corresponding method implemented.)

		Default behaviour is to exit with an error message.
		'''		
		die "Unknown method '$name' in class '" self.class.name "'"
	}


	method init {args} {
		'''
		This is the message that each object receives when it is first
		created. Its implementation is expected to initialize the new object.
		'''
	}

	method isNil_get {} {
		"Returns a true value if this object is nil, false otherwise."
		return nil
	}

	method op_Equals {other} {
		'''
		Test if this object is equal to C<other>.  This is the implementation
		of the C<==> operator.
		'''

		return (self === other)
	}


	method at {index} {
		'''
		Sequence Protocol: Return the item at position C<index>.  Indexes
		must be contiguous and start at zero.
		'''

		die "Not indexable."
	}

	method atPut {index value} {
		'''
		Sequence Protocol: If this object is indexable, store C<value> at
		position C<index> and return C<value>.  Indexes start at zero and
		must be contiguous.
		'''

		die "Not indexable."
	}

	method size_get {} {
		'''
		Sequence Protocol: Return the number of items in this object.
		'''
		die self.class " is not indexable."
	}

	method maker_get {} {
		'''
		Sequence protocol: return a function which will create a collection
		suitable for holding the contents of self and which takes one argument,
		a number specifying the size.  It defaults to C<listSized>.
		'''
		return listSized
	}

	method isIndexable_get {} {
		'''
		Tests if this object can be treated as a sequence (i.e. implements
        the sequence protocol).  If true, the object must implement at least
		C<at>, C<size> and C<maker> as expected and C<atPut> should either
		behave as expected as well or fail with an error.
		'''

		return nil
	}

	method last_get {} {
		'''
		Sequence Protocol: Return the index of the last item in this
		object.
		'''
		return (self.size - 1)
	}

	method printable_get {} {
		"Return a human-readable textual represention of this object."
		var cl = self.class.name
		var a = [if ((cl@0).isVowel) {value "an"} {value "a"}]

		return "$a $cl"
	}

	# Copy protocol.
	method shallowCopy {} {
		"Make a copy of this object without copying the objects it references."
		die "Called abstract shallowCopy"
	}
	method copy {} {
		"Make a copy of this object."
		return [self->shallowCopy]
	}

	# Needed for test case
	method self_get {} {
		"Return this object."
	}

	# Comparison behaviour
	method op_Lt {obj} {
		"Operator C<E<lt>>: Test if self is less than C<obj>."
		return (self <= obj && self != obj)
	}

	method op_Lte {obj} {
		"Operator C<E<lt>=>: Abstract method. Subclasses must implement this."
		die "Called abstract op_Lte on " self.class.name
	}

	method op_Gt {obj} {
		"Operator C<E<gt>>: Test if self is greather than C<obj>."
		return [not (self <= obj)]
	}

	method op_Gte {obj} {
		"Operator C<E<gt>=>: Test if self is greater than or equal to C<obj>."
		return (self > obj || self == obj)
	}
}

_class_ext Number {
	'''
	C<Number> is the class of all (built-in) number types in Deck.
	Instances are floating-point values.
	'''

	# Double-dispatch methods
	mdoc addNumber {num} "Add self to number C<num>"
	method op_Add {obj} {
		"C<+> operator.  Performs addition."
		return [obj->addNumber self]
	}

	mdoc subNumber {num} "Subtract self from C<num>"
	method op_Sub {obj} {
		"C<-> operator.  Performs subtraction."
		return [obj->subNumber self]
	}

	mdoc modNumber {num} "Return C<num> modulo self."
	method op_Mod {obj} {
		"C<%> operator.  Performs the modulo operation."
		return [obj->modNumber self]
	}

	mdoc multNumber {num} "Return C<num> multiplied by C<self>."
	method op_Mult {obj} {
		"C<*> operator.  Performs multiplication."
		return [obj->multNumber self]
	}

	mdoc divNumber {num} "Return C<num> divided by C<self>."
	method op_Div {obj} {
		"C</> operator.  Performs division."
		return [obj->divNumber self]
	}

	mdoc divTruncNumber {num} "Return C<num> divided by C<self> and rounded
       toward zero."
	method op_DivTrunc {obj} {
		"C<//> operator.  Performs division, truncating to the nearest int."
		return [obj->divTruncNumber self]
	}

	mdoc lteNumber {num} "Return true if C<num> is less than or equal to 
       C<self>."
	method op_Lte {obj} {
		"C<E<lt>=> operator.  Performs greater-than-or-equal-to test."
		return [obj->lteNumber self]
	}

	mdoc powNumber {num} "Return C<num> raised to the power of C<self>."
	method op_Pow {obj} {
		"C<**> operator.  Return C<self> raised to the power of C<other>."
		return [obj->powNumber self]
	}

	mdoc bitOrNumber {num} "Return C<num> bitwise ORed with C<self>.
       Both are first truncated to the nearest integer."
	method op_BitOr	{obj} {
		"C<|> operator.  Perform bitwise OR operation.  Fractional arguments
         are first truncated toward zero."
		return [obj->bitOrNumber self]
	}

	mdoc bitXorNumber {num} "Return C<num> bitwise XORed with C<self>.
       Both are first truncated to the nearest integer."
	method op_BitXor {obj} {
		"C<^> operator.  Perform bitwise exclusive-OR operation.  Fractional
         arguments are first truncated toward zero."
		return [obj->bitXorNumber self]
	}

	mdoc bitAndNumber {num} "Return C<num> bitwise ANDed with C<self>.
       Both are first truncated to the nearest integer."
	method op_BitAnd {obj} {
		"C<&> operator.  Perform bitwise AND operation.  Fractional arguments
         are first truncated toward zero."
		return [obj->bitAndNumber self]
	}

	# Optional comparisons.  Object already implements them but these
	# versions are (probably) faster.
	mdoc ltNumber {num} "Test if C<num> is less than C<self>."
	method op_Lt {obj} {
		"C<E<lt>> operator. Test if C<self> is less than C<obj>.  
         This overrides the version in C<Object> for no good reason."
		return [obj->ltNumber self]
	}

	mdoc gtNumber {num} "Test if C<num> is greater than C<self> "
	method op_Gt {obj} {
		"C<E<gt>> operator. Test if C<self> is greater than C<obj>.
         This overrides the version in C<Object> for no good reason."
		return [obj->gtNumber self]
	}

	mdoc gteNumber {num} "Test if C<num> is greater than or equal to C<self> "
	method op_Gte {obj} {
		"C<E<gt>=> operator.  Test if C<self> is greater than or equal to
         C<self>.  This overrides the version in C<Object> for no good reason."
		return [obj->gteNumber self]
	}

	mdoc op_Equals {obj} "Test if C<self> and C<obj> have the same numeric
        value.  (Non-numbers clearly do not.)"

	method shallowCopy {} {
		"Return self, since Numbers are immutable."
		return self
	}

	method printable_get {} {
		"Standard C<printable> attribute."
		return "$self"
	}
}

_class_ext Nil {
	'''
	C<Nil> is the type of the object representing uninitialized variables.
	There is only one instance, the global constant C<nil>.  Unset variables
	are initialized to nil, as are empty lists.
	'''

	method isNil_get {} {
		"Test if this object is C<nil>. Returns true."
		return true
	}
	method printable_get {} {
		"Standard C<printable> attribute."
		return "nil"
	}

	method shallowCopy {} {
		"Return C<self> since nil is immutable."
		return self
	}
}

_class_ext List {
	'''
	C<List> is the fundamental Deck list type.  Unlike most Lispish languages,
	Deck does not present its lists as linked lists of cells.  Instead, a
	Deck C<List> is an array (i.e. a "vector") of object references whose
	individual items can be accessed with the C<at> and C<atPut> methods
	(usually hidden by the C<@> operator).  The indexes start at zero and
	increase to the number of items minus one.

	This is different from most Lispish languages, where a list is implemented
	as a linked list of pairs of references (CONS cells).

	C<List> implements the sequence protocol: C<at>, C<atPut>, C<size>,
	C<maker> C<isIndexable> returns true.
	'''

	mdoc at {index} \
		"Sequence Protocol: Return the item at position C<index>.  Indexes
		must be contiguous and start at zero."

	mdoc atPut {index value} \
		"Sequence Protocol: Store C<value> at position C<index> and
		 return C<value>.  Indexes start at zero and must be
		 contiguous."

	mdoc size_get {} \
		"Sequence Protocol: Return the number of items in this object."

	mdoc shallowCopy {} \
		"Return a copy of C<self> without copying the items it references."

	method isIndexable_get {} {
		"Returns true, since C<List> implements the sequence protocol."
		return 1
	}

	method printable_get {} {
		"Return a human-readable textual represention of this C<List>."
		const MAX = 5
		(self.size < MAX + 3) && [return "[@{self}]"]

		var sublist = [listSized MAX]

		var index = 0
		while (index < MAX) {
			sublist@index = self@index
			index = index + 1
		}

		var last = self @ -1
		return "[@sublist .. $last]"
	}

	method op_Equals {obj} {
		"C<==> operator: True if C<obj> is also a List and all elements
         equal (via C<op_Equals>) the corresponding element in C<obj>."
		return [_seq_Equals self obj]
	}

	method op_Add {otherSeq} {
		"C<+> operator, overloaded: Returns C<self> and C<other> concatenated
         together.  The result is the type returned by C<maker> (C<list> in
         this case)."
		var result = [listSized (self.size + otherSeq.size)]
		_write_seq self otherSeq result
		return result
	}

}

_class_ext Stringlike {
	'''
	This is the abstract base class for several classes representing
	various sequences of binary or specially-encoded data.  It should
	not be used directly.
	'''

	mdoc at {index} \
		"Sequence Protocol: Return the item at position C<index>.  Indexes
		must be contiguous and start at zero."

	mdoc atPut {index value} \
		"Sequence Protocol: Store C<value> at position C<index> and
		 return C<value>.  Indexes start at zero and must be
		 contiguous. C<value> must be of a type that can be stored in this
         object."

	mdoc size_get {} \
		"Sequence Protocol: Return the number of items in this object."

	method isIndexable_get {} {
		"Returns true, since all C<Stringlike> subclasses implement the
         sequence protocol."
		return 1
	}
}


perlproc _downcase {s} '''$s =~ y/A-Z/a-z/;return $s;'''
perlproc _isspace {s} '''return $s =~ /^\s+$/;'''

_class_ext String {
	"
	C<String> instances contain human-readable text which can be
	printed to the console or stored in a file.  The class implements
	the sequence protocol but the objects stored or retrieved from a
	C<String> must themselves be strings of length 1.  

	Unlike many other languages, Deck does not have a character type.
	Instead, strings are encoded in some manner and it is best not to
	make assumptions about the details.  In particular, you should
	B<never> use a C<String> to hold arbitrary binary data as this
	will break when Deck switches to using UTF8.  Use C<ByteArray> for
	that.

	That being said, C<Strings> are currently 7-bit ASCII and all operations
	are performed within the C<C> locality.
	"

	mdoc op_Equals {obj} \
		"C<==> operator: True if C<obj> is also a C<String> or C<Symbol>
         and all characters match the the corresponding characters in C<obj>."

	mdoc shallowCopy {} \
		"Create and return a copy of C<self>."

	method maker_get {} {
		"Sequence protocol: return a function which will create a collection
		 suitable for holding the contents of self and which takes one
         argument, a number specifying the size.  In this case, it's
         C<stringSized>."
		return stringSized
	}

	method isVowel_get {} {
		"Return true if C<self> contains one character and that character
         is an ASCII vowel."
		(self.size != 1) && [return false]

		var lc = [self->lowercase]

		for v in [list "a" "e" "i" "o" "u"] {
			if (lc == v) {
				return true
			}
		}
		return false
	}

	method isSpace_get {} {
		"Test if C<self> is all ASCII whitespace."
		return [_isspace self]
	}

	method lowercase {} {
		"Return a copy of C<self> with all uppercase characters replaced
         with their lowercase equivalents."
		return [_downcase self]
	}

	method printable_get {} {
		"Return C<self>; a string is its own printable."
		return self
	}

	method op_Add {otherString} {
		"C<+> operator, overloaded: Returns C<self> and C<other> concatenated
         together.  The result is the type returned by C<maker> (C<String> in
         this case).  Note that C<otherString> does B<not> have to be a string
         but B<must> contain only strings of length 1 (i.e. characters)."
		var result = [stringSized (self.size + otherString.size)]
		_write_seq self otherString result
		return result
	}

	method op_Lte {other} {
		"C<E<lt>=> operator: lexically compares C<self> with C<other> (which
         B<must> be a C<String> or C<Symbol>) and returns true if self comes
         before C<other> or if they are equal.  The other comparisons are
         implemented in C<Object>."
		if (other.class == Symbol) {
			other = [unintern other]
		}

		(other.class == String) \
			|| [die "Comparing string with " other.class ]

		return [_str_lte self other]
	}

}


_class_ext Symbol {
	'''
	Symbols are mostly used to represent names in expressions.  They
	are similar to strings in that they contain human-readable text.  However,
	there are some notable differences:

	=over

	=item 1.

	Symbols are immutable.  C<atPut> will fail on one.

	=item 2.

	Symbols are unique.  There is only ever one symbol with a particular
	value.

	=back

	C<Symbol> implements the sequence protocol but as mentioned above, the
	C<atPut> method will fail.

	C<Symbols> can be converted to and from strings via the C<intern> and 
	C<unintern> functions.  Symbol constants are tokens beginning with the
	C<:> character, e.g. ":foo".
	'''

	method printable_get {} {return ":$self"}

	method op_Equals {obj} {
		(obj.class == String) && [return ("$self" == obj)]
		return (self === obj)
	}

	method op_Add {obj} {
		var result = [stringSized (self.size + obj.size)]
		_write_seq self obj result
		return result
	}

	method shallowCopy {} {return self}

	method op_Lte {other} {
		return ([unintern self] <= other)
	}

	method maker_get {} {return stringSized}  # symbols are immutable
}



_class_ext ByteArray {
	'''
	A C<ByteArray> is a sequence of 8-bit bytes.  Any sequence of bytes
	is allowed.

	C<ByteArray> implements the sequence protocol but will fail if you
	attempt to store a value in it that is not an integer between 0 and 255.
	'''
   	method printable_get {} {
		const MAXSIZE = 5
		var {count = MAXSIZE}

		var dotdot = " .. "
		var last = [sprintf "0x%02x" (self@ -1)]

		if (self.size < MAXSIZE + 3) {
			dotdot = ""
			last = ""
			count = self.size
		}

		var formatted = [listSized count]
		var index = 0
		while (index < count) {
			formatted@index = [sprintf "0x%02x" (self@index)]
			index = index + 1
		}

		return "[byteArray @formatted$dotdot$last]"
   	}

	method op_Equals {obj} {return [_seq_Equals self obj]}

	method op_Add {otherBArray} {
		var result = [bytesSized (self.size + otherBArray.size)]
		_write_seq self otherBArray result
		return result
	}

	method maker_get {} {return bytesSized}
}

_class_ext Struct {
	'''
	C<Struct> is the base class for all traditional classes.  A traditional
	class is a class whose data is stored in named fields.

	This is an abstract base class and cannot be instantiated.  All subclasses
	should implement the method C<init> to initialize the fields when an
	instance is created.

	C<Struct> subclasses are typically instantiated using the C<new> method or
	procedure.
	'''
}


_class_ext Class {
	'''
	All classes (i.e. types) in Deck are themselves objects and those objects
	are instances of type C<Class>.  This includes C<Class> itself.

	C<Class> serves two purposes: to provide information about the class and
	to create new instances via its C<new> method.
	'''

	method printable_get {} {
		var nm = self.name
		(nm.size == 0) && [return "a Class"]
		
		return "class $nm"
	}
}

_class_ext Quote {
	'''
	C<Quote> instances are used to represent quotation in Deck expressions.
	Each C<Quote> contains a single data value which may be accessed using
	the C<value> attribute.  The presence of the C<Quote> in an expression
	is used to indicate that the value it wraps should not be evaluated in
	the usual way.

	You will only ever need to use a C<Quote> when creating Deck expressions
	to be compiled later by the Deck compiler.
	'''

	method printable_get {} {
		var v = self.value
		return "[quote $v]"
	}

	method op_Equals {obj} {
		(self.class == obj.class) || [return false]
		return (self.value == obj.value)
	}

	method shallowCopy {} {
		return [quote self.value]
	}
}


_class_ext Macro {
	"C<Macro> is the class of all Deck macros."
	method shallowCopy {} {return self}
	method printable_get {} {return "<macro>"}
}

_class_ext Function {
	"C<Function> is the class of most Deck functions (procs, subs, etc)."
	method shallowCopy {} {return self}
	method printable_get {} {return "<function>"}
}

_class_ext Method {
	"C<Method> is the class of all Deck methods."
	method shallowCopy {} {return self}
	method printable_get {} {return "<method>"}
}

_class_ext MethodCall {
	'''
	C<MethodCall> is the class of all method call objects.  Method calls are
	callable objects that will call a specific method on a specific object,
	both of which are captured inside the C<MethodCall>.

	Instances of C<MethodCall> are the result of a call to C<getMethod> or
	C<getSuperMethod> (which are usually called by the macro C<-E<gt>>).
	'''
	method shallowCopy {} {return self}
	method printable_get {} {return "<method call>"}
}

_class_ext PerlObj {
	'''
	C<PerlObj> is a wrapper around some Perl data.  Perl functions created
	using C<perlproc> can return Perl data that has no meaningful
	representation inside Deck and these can then be passed to other Perl
	functions.

	For example, a Deck wrapper around a Perl library may use a C<PerlObj> to
	hold a reference to an instance of a class defined in the library.

	There is no way to modify a PerlObj in Deck.
	'''


	# method printable_get is written in perl
}


# Equality support.  This should really be part of a trait, but Deck
# doesn't implement them yet.
proc _seq_Equals {left right} {
	(left.class === right.class) || [return false]
	(left.size == right.size) || [return false]

	var index = 0
	while (index < left.size) {
		(left@index == right@index) || [return false]
		index = index + 1
	}

	return true
}


# Write the contents of src1 and src2 sequentially onto dest.  Assumes
# that dest is long enough and of the right type to hold the contents.
proc _write_seq {src1 src2 dest} {
	var index = 0
	for item in src1 {
		dest@index = item
		index = index + 1
	}

	for item in src2 {
		dest@index = item
		index = index + 1
	}
}


proc cmp {left right} {
	'''
	Compare C<left> and C<right> and return -1, 0 or 1 if C<left> is less than,
	equal to or greater than C<right>.
	'''
	(left == right)	&& [return 0]
	(left > right)	&& [return 1]
	return -1
}
const \<=> = cmp

# Return the absolute value of a number
proc abs {n} {
	"Return the absolute value of C<n>, a Number."
	if (n < 0) {
		return [-n]
	}
	return n
}

# The not-equal operator
proc \!= {left right} {
	"Return C<true> if C<left> and C<right> are not equal (C<==>)."
	return [not (left == right)]
}

proc size {aList} {return aList.size}
proc last {aList} {return aList.last}

proc typeof {obj} {return [intern obj.class.name]}

proc asList {seq} {
	'''
	Return a list containing the contents of C<seq>, an object that
	implements the list protocol.
	'''

	var result = [listSized seq.size]
	var index = 0
	for elem in seq {
		result@index = elem
		index = index + 1
	}

	return result
}


perlproc _perlsort {fn ls} '''
  $fn->checkFun(" in _sort perlfunc.");
  my $result = [sort {$fn->($a, $b)->perlForm()} @{$ls}];
  return $result;
'''

mproc sort {
	sub 2 ucmp
	seq
} {
	'''
	Return a copy of C<seq> with the elements sorted according to C<ucmp>.

	C<ucmp> should take two arguments and return -1, 0 or 1 depending on
	whether the first argument is less than, equal to or greater than the
	second argument.  (This is the same interface as C<cmp>).

	C<seq> is an object that implements the sequence protocol and the return
	value is constructed by the function returned by C<seq>'s C<maker>
	attribute.
	'''

	var sortList = seq
	if (sortList.class != List) {
		sortList = [asList sortList]
	}

	var resultList = [_perlsort [perlobj ucmp] [perlobj sortList]]

	(seq.class == List) && [return resultList]

	var result = [(seq.maker) seq.size]
	_write_seq resultList :[] result

	return result
}

mproc reduce {
	sub 1 filter
	seq
} {
	'''
	Apply function C<filter> to every element of sequence C<seq> and return
	another sequence containing only the elements on which C<filter> returned
	a true value.  The return value's type is compatible with C<seq>'s.
	'''

	var result = [(seq.maker) seq.size]
	var index = 0

	for elem in seq {
		if ([filter elem]) {
			result@index = elem
			index = index + 1
		}
	}

	return [slice result 0 (index - 1)]
}
			


# Insert spacer between all elements in aList
# proc withSpacer {aList spacer} {

# 	var rs = [size aList] * 2
# 	if ([size aList] % 2
# 	var result = [listSized 


# }



class Interval Struct {
	'''
	Instances of C<Interval> mimic a list containing a consecutive list of
	numbers as defined by the C<new> arguments C<startVal>, C<endVal> and
	C<incrVal>, all Numbers truncated to the nearest integer. C<startVal> is
	the first number, C<endVal> is the last (possibly approximated) and 
	C<incrVal> is the increment from one value to the next.

	The main purpose of C<Interval> is to provide a way to do a for/foreach
	loop over a series of integers without having to create an actual array
	of integers.  This allows you to do stuff like this:

	    C<for i in (1 .. 10000000) { ... }>

	instead of

	    C<var x = 0; while (x < 10000000) { ... ; x = x + 1 }>

	(The C<..> operator creates an C<Interval>.)

	C<Intervals> implement the sequence protocol but C<atPut> fails with
	an error.
	'''

	readable start
	var length
	var incr

	method op_Equals {other} {
		(other.class == self.class) || [return false]
		return (start == other.start && length == other.size)
	}

	method end_get {} {
		return (self @ (length - 1))
	}

	method _init {startVal endVal incrVal} {
		start = [int startVal]
		var end = [int endVal]
		incr = [int incrVal]

		length = ([abs (end - start)] + 1)
	}

	method isIndexable_get {} {return 1}
	method atPut {index value} {
		die "Attempted to write to read-only object."
	}

	method size_get {} {return length}

	method at {index} {
		if (index >= length) {
			die "Attempted to read past end of interval."
		}

		return (start + (index * incr))
	}

	method printable_get {} {
		var end = start + (length * incr) - 1

		var by = ""
		if ([abs incr] != 1) {
			by = " (by $incr)"
		}
 
		return "$start .. $end$by"
	}

	method isTrue_get {} {
		return (self.size > 0)
	}
}


# Produce a list of elements between start and end separated by 1
proc \.. {start end} {
	'''
	Create an C<Interval> for the range from C<start> to C<end> with an 
	increment of 1.
	'''

	var by = 1
	if (end < start) {
		by = -1
	}
	return [Interval->new start end by]
}
const range = \..


# Extract a sublist from aList
proc slice {seq start end} {

	if (end == nil || end > [last seq]) {
		end = seq.last
	}

	if (start > end || start > [last seq]) {
		return [(seq.maker) 0]
	}

	var range = (start .. end)
	var result = [(seq.maker) [size range]]
	var index = 0
	foreach n in range {
		result@index = seq@n
		index = index + 1
	}

	return result
}

# Concatenate all list-like arguments together.
proc concat {args} {
	var len = 0
	foreach l in args {
		len = len + [size l]
	}

	var result = [((args@0).maker) len]
	var pos = 0
	foreach l in args {
		foreach elem in l {
			result@pos = elem
			pos = pos + 1
		}
	}

	return result
}


perlproc _rand {} ''' return rand(1); '''

proc rand {max} {
	return (max * [_rand])
}

proc irand {max} {
	return [int [rand max]]
}


# Return a shuffled copy of seq
proc shuffled {origSeq} {
	var seq = [origSeq->shallowCopy]

	for index in (seq.last .. 1) {
		var pick = [rand (index - 1)]
		
		var tmp = seq@pick
		seq@pick = seq@index
		seq@index = tmp
	}

	return seq
}


perlproc _printstr {s} ''' print $s; '''

proc say {args} {
	"Write the printable form of each argument in turn on stdout."
	for obj in args {
		_printstr obj.printable
	}
}

proc puts {args} {
	'''
	Write the printable form of each argument in turn on stdout followed by
	a newline.
	'''

	apply say args
	say "\n"
}



