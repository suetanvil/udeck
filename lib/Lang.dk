# The Deck system library.  Contents are imported into module Lang
# after startup.

# no package declaration because this module has already been created.

var Version = '0.01';


# Return the absolute value of a number
proc abs {n} {
	if (n < 0) {
		return [-n]
	}
	return n
}

# The not-equal operator
proc != {l r} {
	return [not (l == r)]
}


# Return the last index in 'aList'
proc last {aList} {
	return ([size aList] - 1)
}


# Base class for all traditional structured objects
class Object {
	method doesNotUnderstand {name args} {
		die "Unknown method '$name'"
	}

	method init {args} {}

	method at {index} {die "Not indexable."}
	method atPut {index value} {die "Not indexable."}
	method size {} {die "Not indexable."}
	method isIndexable {} {return nil}

	method isTrue {} {
		if {self->isIndexable} {
			return (self->size > 0)
		} else {
			return nil
		}
	}

#	method printStr {} {
#		return [mkstr "[new " [typeof self] "]"]
#	}
}



# This object mimics a list containing a consecutive sequence of
# numbers
class Interval Object {
	readable start
	var length incr

	method end_get {} {
		return (self @ (length - 1))
	}

	method _init {startVal endVal incrVal} {
		start = [int startVal]
		var end = [int endVal]
		incr = [int incrVal]

		if (start > end) {
			incr = [- incr]
		}

		length = ([abs (end - start)] + 1)
		
	}

	method isIndexable {} {return 1}
	method atPut {index value} {
		die "Attempted to write to read-only object."
	}

	method size {} {return length}

	method at {index} {
		if (index >= length) {
			die "Attempted to read past end of interval."
		}

		return (start + (index * incr))
	}
}


# Produce a list of elements between start and end separated by 1
proc range {start end} {
	return [new Interval start end 1]
}
const \.. = range


# Extract a sublist from aList
proc slice {aList start end} {

	if (end == nil || end > [last aList]) {
		end = [last aList]
	}

	if (start > end || start > [last aList]) {
		return :[]
	}

	var range = (start .. end)
	var result = [listSized [size range]]
	var index = 0
	foreach n in range {
		result@index = aList@n
		index = index + 1
	}

	return result
}

# Concatenate all list-like arguments together.
proc concat {args} {
	var len = 0
	foreach l in args {
		len = len + [size l]
	}

	var result = [listSized len]
	var pos = 0
	foreach l in args {
		foreach elem in l {
			result@pos = elem
			pos = pos + 1
		}
	}

	return result
}


