# The Deck system library.  Contents are imported into module Lang
# after startup.

# no package declaration because this module has already been created.

var Version = '0.01';

perlproc sprintf {fmt args} '''sprintf ($fmt, @args)'''

const {
	true = 1
	false = nil
}

proc _seq_Equals
proc _write_seq


_class_ext Number {

	# Double-dispatch methods
	method op_Add      {obj} {return [obj->addNumber self]}
	method op_Sub      {obj} {return [obj->subNumber self]}
	method op_Mod      {obj} {return [obj->modNumber self]}
	method op_Mult     {obj} {return [obj->multNumber self]}
	method op_Div      {obj} {return [obj->divNumber self]}
	method op_DivTrunc {obj} {return [obj->divTruncNumber self]}
	method op_Lt       {obj} {return [obj->ltNumber self]}
	method op_Lte      {obj} {return [obj->lteNumber self]}
	method op_Gt       {obj} {return [obj->gtNumber self]}
	method op_Gte      {obj} {return [obj->gteNumber self]}
	method op_Pow	   {obj} {return [obj->powNumber self]}
	method op_BitOr	   {obj} {return [obj->bitOrNumber self]}
	method op_BitXor   {obj} {return [obj->bitXorNumber self]}
	method op_BitAnd   {obj} {return [obj->bitAndNumber self]}

	method printable_get {} {return "$self"}
}

# Base class for all traditional structured objects
_class_ext Object {
	method doesNotUnderstand {name args} {
		die "Unknown method '$name' in class '" self.class.name "'"
	}

	method init {args} {}

	method isNil_get {} {return nil}
	method op_Equals {other} {return (self === other)}

	method at {index} {die "Not indexable."}
	method atPut {index value} {die "Not indexable."}
	method size_get {} {die self.class " is not indexable."}
	method isIndexable_get {} {return nil}
	method last_get {} {return (self.size - 1)}

	method printable_get {} {
		var cl = self.class.name
		var a = [if ((cl@0).isVowel) {val "an"} {val "a"}]

		return "$a $cl"
	}

	# Needed for test case
	method self_get {} {}
}


_class_ext Nil {
	method isNil_get {} {return 1}
	method printable_get {} {return "nil"}
}

_class_ext List {
	method isIndexable_get {} {return 1}
	method printable_get {} {
		const MAX = 5
		(self.size < MAX + 3) && [return "[list @{self}]"]

		var sublist = [listSized MAX]

		var index = 0
		while (index < MAX) {
			sublist@index = self@index
			index = index + 1
		}

		var last = self @ -1
		return "[list @sublist .. $last]"
	}

	method op_Equals {obj} {return [_seq_Equals self obj]}

	method op_Add {otherSeq} {
		var result = [listSized (self.size + otherSeq.size)]
		_write_seq self otherSeq result
		return result
	}

}

_class_ext Stringlike {
	method isIndexable_get {} {return 1}
}


perlproc _downcase {s} '''$s =~ y/A-Z/a-z/;return $s;'''

_class_ext String {
	method isVowel_get {} {
		(self.size != 1) && [return false]

		var lc = self.lowercase

		for v in [list "a" "e" "i" "o" "u"] {
			if (lc == v) {
				return true
			}
		}
		return false
	}

	method lowercase_get {} {return [_downcase self]}
	method printable_get {} {return "'$self'"}

	# op_Equals is implemented in Perl

	method op_Add {otherString} {
		var result = [stringSized (self.size + otherString.size)]
		_write_seq self otherString result
		return result
	}

}


_class_ext Symbol {
	method printable_get {} {return ":$self"}

	method op_Equals {obj} {
		(obj.class == String) && [return ("$self" == obj)]
		return (self === obj)
	}

	method op_Add {obj} {
		var result = [stringSized (self.size + obj.size)]
		_write_seq self obj result
		return result
	}
}

_class_ext ByteArray {
   	method printable_get {} {
		const MAXSIZE = 5
		var {count = MAXSIZE}

		var dotdot = " .. "
		var last = [sprintf "0x%02x" (self@ -1)]

		if (self.size < MAXSIZE + 3) {
			dotdot = ""
			last = ""
			count = self.size
		}

		var formatted = [listSized count]
		var index = 0
		while (index < count) {
			formatted@index = [sprintf "0x%02x" (self@index)]
			index = index + 1
		}

		return "[byteArray @formatted$dotdot$last]"
   	}

	method op_Equals {obj} {return [_seq_Equals self obj]}

	method op_Add {otherBArray} {
		var result = [bytesSized (self.size + otherBArray.size)]
		_write_seq self otherBArray result
		return result
	}

}

_class_ext Struct {

}

_class_ext Class {
	method printable_get {} {
		var nm = self.name
		(nm.size == 0) && [return "a Class"]
		
		return "class $nm"
	}
}

_class_ext Quote {
	method printable_get {} {
		var v = self.value
		return "[Quote $v]"
	}

	method op_Equals {obj} {
		(self.class == obj.class) || [return false]
		return (self.value == obj.value)
	}
}

_class_ext Macro {
}

_class_ext Function {
}

_class_ext Method {
}

_class_ext MethodCall {
}

_class_ext PerlObj {
}


# Equality support.  This should really be part of a trait, but Deck
# doesn't implement them yet.
proc _seq_Equals {left right} {
	(left.class === right.class) || [return false]
	(left.size == right.size) || [return false]

	var index = 0
	while (index < left.size) {
		(left@index == right@index) || [return false]
		index = index + 1
	}

	return true
}


# Write the contents of src1 and src2 sequentially onto dest.  Assumes
# that dest is long enough and of the right type to hold the contents.
proc _write_seq {src1 src2 dest} {
	var index = 0
	for item in src1 {
		dest@index = item
		index = index + 1
	}

	for item in src2 {
		dest@index = item
		index = index + 1
	}
}



# Return the absolute value of a number
proc abs {n} {
	if (n < 0) {
		return [-n]
	}
	return n
}

# The not-equal operator
proc \!= {l r} {
	return [not (l == r)]
}

proc size {aList} {return aList.size}
proc last {aList} {return aList.last}


# Insert spacer between all elements in aList
# proc withSpacer {aList spacer} {

# 	var rs = [size aList] * 2
# 	if ([size aList] % 2
# 	var result = [listSized 


# }



# This object mimics a list containing a consecutive sequence of
# numbers
class Interval Struct {
	readable start
	var length
	var incr

	method end_get {} {
		return (self @ (length - 1))
	}

	method _init {startVal endVal incrVal} {
		start = [int startVal]
		var end = [int endVal]
		incr = [int incrVal]

		if (start > end) {
			incr = [- incr]
		}

		length = ([abs (end - start)] + 1)
		
	}

	method isIndexable_get {} {return 1}
	method atPut {index value} {
		die "Attempted to write to read-only object."
	}

	method size_get {} {return length}

	method at {index} {
		if (index >= length) {
			die "Attempted to read past end of interval."
		}

		return (start + (index * incr))
	}

	method printable_get {} {
		var end = start + (length * incr)

		var by = ""
		if ([abs incr] != 1) {
			by = " (by $incr)"
		}
 
		return "$start .. $end$by"
	}
}


# Produce a list of elements between start and end separated by 1
proc \.. {start end} {
	return [new Interval start end 1]
}
const range = \..


# Extract a sublist from aList
proc slice {aList start end} {

	if (end == nil || end > [last aList]) {
		end = [last aList]
	}

	if (start > end || start > [last aList]) {
		return :[]
	}

	var range = (start .. end)
	var result = [listSized [size range]]
	var index = 0
	foreach n in range {
		result@index = aList@n
		index = index + 1
	}

	return result
}

# Concatenate all list-like arguments together.
proc concat {args} {
	var len = 0
	foreach l in args {
		len = len + [size l]
	}

	var result = [listSized len]
	var pos = 0
	foreach l in args {
		foreach elem in l {
			result@pos = elem
			pos = pos + 1
		}
	}

	return result
}


