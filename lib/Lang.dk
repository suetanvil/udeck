# The Deck system library.  Contents are imported into module Lang
# after startup.

# no package declaration because this module has already been created.

var Version = '0.01';


_class_ext Number {

	# Double-dispatch methods
	method op_Add {obj} {return [obj->addNumber self]}
	method op_Mod {obj} {return [obj->modNumber self]}
}

# Base class for all traditional structured objects
_class_ext Object {
	method doesNotUnderstand {name args} {
		die "Unknown method '$name' in class '" self.class.name "'"
	}

	method init {args} {}

	method at {index} {die "Not indexable."}
	method atPut {index value} {die "Not indexable."}
	method size_get {} {die self.class " is not indexable."}
	method isIndexable_get {} {return nil}

	method isNil_get {} {return nil}
}


_class_ext Nil {
	method isNil_get {} {return 1}
}

_class_ext List {
	method isIndexable_get {} {return 1}
}

_class_ext Stringlike {
	method isIndexable_get {} {return 1}
}



# Return the absolute value of a number
proc abs {n} {
	if (n < 0) {
		return [-n]
	}
	return n
}

# The not-equal operator
proc != {l r} {
	return [not (l == r)]
}


# Return the last index in 'aList'
proc last {aList} {
	return ([size aList] - 1)
}


# Insert spacer between all elements in aList
# proc withSpacer {aList spacer} {

# 	var rs = [size aList] * 2
# 	if ([size aList] % 2
# 	var result = [listSized 


# }



# This object mimics a list containing a consecutive sequence of
# numbers
class Interval Struct {
	readable start
	var length incr

	method end_get {} {
		return (self @ (length - 1))
	}

	method _init {startVal endVal incrVal} {
		start = [int startVal]
		var end = [int endVal]
		incr = [int incrVal]

		if (start > end) {
			incr = [- incr]
		}

		length = ([abs (end - start)] + 1)
		
	}

	method isIndexable_get {} {return 1}
	method atPut {index value} {
		die "Attempted to write to read-only object."
	}

	method size {} {return length}

	method at {index} {
		if (index >= length) {
			die "Attempted to read past end of interval."
		}

		return (start + (index * incr))
	}
}


# Produce a list of elements between start and end separated by 1
proc range {start end} {
	return [new Interval start end 1]
}
const \.. = range


# Extract a sublist from aList
proc slice {aList start end} {

	if (end == nil || end > [last aList]) {
		end = [last aList]
	}

	if (start > end || start > [last aList]) {
		return :[]
	}

	var range = (start .. end)
	var result = [listSized [size range]]
	var index = 0
	foreach n in range {
		result@index = aList@n
		index = index + 1
	}

	return result
}

# Concatenate all list-like arguments together.
proc concat {args} {
	var len = 0
	foreach l in args {
		len = len + [size l]
	}

	var result = [listSized len]
	var pos = 0
	foreach l in args {
		foreach elem in l {
			result@pos = elem
			pos = pos + 1
		}
	}

	return result
}


