

Notes:

	-Now uses square brackets for infix but tests don't all do that.

	-let's use ':' as the quote.

	-Tolerates [x], {x} and :[x] as proc argument lists.

	-** is not right-associative.

	-I think I'll bow to starting arrays with index 0.

	- Unary minus: space (e.g. "- 1") -> binary, no space (e.g. "-1") -> unary

	- if and while can take either a LoL or a single unquoted list as
	  an expression and either will be turned into a sub.  New subify
	  behaviour.
		-this applies to all subified functions.  Will probably also be default
		 behaviour for subified mproc arguments

	- okay, user-defined macros use the function arg convention.

	- macros are always defined at the global (module) level.

	- INIT ==> init

	- 'new' used to create objects.

	- user-defined operators all have the same precedence--just above '='.
		-will also be above ',' if I add that.

	- in float literals, the character following the '.' may not be an
	  underscore.

	- => operator creates closures
		-lhs is arguments, rhs body.  Both must be QtLoLs.
		-auto-paren'd like '.' and '->'
		-use rename changed to '='.

	- '->' now honoured in entire expression.  More consistent.

	- 'lookup' and 'defined' only query the global namespace.

	- '||' and '&&' imply infix in LoLs.

	- DECKLIB env. var. points to the deck library.

	- 'val' has been renamed to 'value'.

	- quote semantics: ':' <value> denotes a quote object, which the
      compiler handles as it will.  ':<symbol>' becomes a symbol
	  object this way.

	- "a.b && [other expr]" doesn't autoparen the '.'.  Note this.


Functions Todo:
X	-listSized



X mprocs:
X 
X 	form: mproc <name> [ [strict? (sub[0..26]?|sym|list) <arg>]* ] <body>
X 
X 	modifiers:
X 		sub[number]		-- If a list, subify's with number arguments.
X 		symbol			-- If a symbol, quote
X 		list			-- If a list, quote
X 		strict			-- Require that the other modifier activate.
X 		
X 	so basically, mproc args must be LoLs.
X 
X 
X =example
X 
X mproc map {
X 	strict sub 1 block
X 	items
X } {
X 	var result = [listSized [block size]]
X 	var index = 0
X 
X 	foreach item in items {
X 		result@index = [block item]
X 		index = index + 1
X 	}
X 
X 	return result
X }
X 
X =done

Perl bindings:
	
Form 1:

X	perluse "File::Handle";
	perlsub split "split";

Form 2:

X	perlproc hello {nm} '''print "Hello, $nm\n";''' 



Forward declarations:

	proc Foo
	
	...

	proc Foo {a b} {....}

or

	mproc map {
		sub1 fn
		aList
	}

	...

	mproc map {
		sub1 fn
		aList
	} { ... }







Todo:
X	-catch arg. count mismatches.

X	- pod
X	- macros
X		-mprocs

X	- namespaces
X		- namespace resolution
X		- packages
X		- with/without clauses
X		- with renames
X		- 'rename' 

X	-_lreturn should have a better name: 'subreturn'?
X	- ARGS needs to be split into interp args and program args.
X		-and update runtests to work with argtest.

	- string interpolation
X		-\[nrfat] now works
X		-$interpolation
		-[interpolation]
X		-@interpolation
X		-hmmm.  What about ':"foo $bar"'
X			-" expressions are syntact shorthand the same way infix
X			 expressions are.

X	- should we allow local macros?
X		-for now, no!

X	- allow _ in numbers
	- scientific notation
X	- the empty symbol should be false
X	- fail49 -- recursive macro
X	- separate interp args from program args
X	- apply
X	- bug: need to unescape all operators
X	- need to check the argument counts of all built-in functions.

X	- intern.
X		-added
X		-need to protect the namespace from badly-formed variables.
X	- boolean not
X	- rename checkLoL and isLoL to checkQuotedLoL and isQuotedLoL
X		-also add unquoted versions	
X	- bug: arg. mismatch error msg is wrong for methods. count is off.	
X	- objects
X	- bug: compiler doesn't catch undefined vars at compile time.
X	- What to do about user-defined operators?
X		-allow them but advise against for now.
X		-need some testing
X	-bug: infix precedence is broken.
X	-bug: 'var' doesn't allow operators as var names.
X	-bug: if (n) doesn't work.  Also (a || b).
X		-should (n) expand to [val n] or should subify do that?
X			-is there a non-control-flow expression that handles this?
X				-no.  Because only CF expressions wrap things in subs.
X	- => operator creates closures
X		-lhs is arguments, rhs body.  Both must be QtLoLs.
X		-auto-paren'd like '.' and '->'
X	-class fn should take an optional intrinsic name.

X	- make everything an object

X	- bug: function calls fail to capture their namespace.
X		-normalize all names at compile time?
X			-no.  sub at runtime needs the module name.
X		-so namespace needs to be in each Context.
X			-function, objects need it; subs, methods don't.
X			1. Add namespace support to contexts.
X			2. Put the namespace into classes.
X			3. Make compile() set the namespaces on procs and objects.
X			4. Make sure normalizeName et. al. use the local
X			   namespace instead of the global one.
X					-replace polymorphic normalizeName() with
X				     overridden def, set, etc.
X					-make Context accessors use findFullName to
X					 qualify everything correctly.
X			5. Fix (uses of):
X				isLegallyAccessible
X					-make lookup and defined take the context as arg.
X					-add a hash of fn's that take the context and use
X					 that instead of the regexp on the name
X					-figure out if we should support the local context
X						-no.  Always 
X					-add fullname.  Should support local--good for testing
X					-make isLegallyAccessible do the right thing.
X	-get rid of println

	- forward declaration of functions
X		1) create class 'UndefinedFunction' for functions that are
X		   declared but not defined.  If called, dies with meaningful
X		   error message.

X		2) make proc const.

X		3) make bodiless 'proc' macro declare the name as an UndefinedFunction.
X			-also add 'proc' to a per-namespace hash of undefined functions

X		4) make 'proc' with body modify the 'const' proc *only* if it
X		   is an UndefinedFunction.

X		5) make 'readfile' check for undefined declared functions at
X	       the end of loading.

X		6) Do the same for mproc.
X			-Make addForward store arg. lists as the value
X			-clearForwards needs to return name and value pairs
X			-builtin_mproc needs to check for argument mismatches
X	-bug: implement '||' and '&&'
X		-also, & and | (bitwise ops)
X	- || and && expressions are now infix in LoLs.
X	-bug: '' is not an empty string.
X	- bug: String.isVowel doesn't work
X		-due to bad || expr.
X			-need to be more stringent about infix/prefix
X			-we can get away with it, I think.
X			-catch unescaped operator in prefix LoL expression
X	-bug: arguments to setters/getters are silently ignored(?)
X	- 'printable' attribute on all builtin classes
X	- == is now a method
X		--need to test all cases.
X	- bug: LL::Class->storeStr() returns a string ref.
X	-get rid of sub 'prim' -- only used once
X	-shallowCopy
X		-copy defaults to shallowCopy
X		-for structs, it's a primitive.
X		-immutables just return self
X		-need quote constructor; update printable
X	- '+' should also concatenate lists and strings
X		-bug: List->op_Add returns the context instead of self.
X		-need to concatenate symbols
X	-need canary to catch broken infix expressions		
X	-bug: "var x = 1 .. 5" doesn't work.
X		-'..' has lower precedence than '='.  WTF?
X	-bug: puts and say should use printable.
X		-and printable needs to lose some storable elements.
X	-deck.pl should be able to find its library no matter where it's
X	 installed.
X		-well, at least the env. var. DECKLIB can be used to set the 
X		library path.
X	-'var x = <y>' should parse the assignment as fully infix.
X	-rename val -- too easy to type instead of var
X		-do? is? value?
X	-bug: var biText = [if (fbuiltin) {value " B<(Built-in)>"} {value ""}] 
X	 doesn't fail and returns perl undef.
X		-varconst is fine
X		-_::if is fine.  Problem is subs shouldn't be compiling.
X		-it's not just 'if'; it's any sub.
X		-AHA! The string gets treated as a docstring and ignored! The
X	     sub returns undef (not NIL). Fixed!
X		-subs shouldn't allow docstrings.
X	-move 'map' to Lang.dk
X	-bug: newlines in strings are doubled.


X	-make the code self-documenting
X		-need sort
X			-need string comparisions
X				-and see if I can merge string and symbol
X					-no, 'cuz of inheritance
X			-need spaceship operator
X				-and should be a function, dude!
X	-class.methods -- list of names of methods implemented by this
X    class only.
X		-docstrings in classes, methods and procs.
X			-map docstrings to global namespace.  Method docstrings go
X			 in <class>-><method> or <class>.<method>.
X		-API:
X			_::docstring_keys -- returns list of names as strings
X			_::docstring_get <key> -- returns the doc info in a list:
X				[:class <name> <builtin> <superclass> <docstring>]
X				[:proc <name> <builtin> <args> <docstring>]
X				[:method <name> <builtin> <classname> <methodname> 
X					<args> <docstring>]
X				[:attrib <name> <builtin> <class> :readable/:writeable/:public
X	                <attrib-name> <docstring>]
X				[:macro <name> <builtin> <args> <docstring>]
X				[:mproc <name> <builtin> <args> <docstring>]
X		-need to explain subify and delay.
X		-need to properly sort non-alnum method keys
X		-need to launder POD codes from macro names
X	-bug: var overriding an argument isn't an error.
X		-looks like redefinition of var isn't caught.
X	-'@' should be a macro
X	-The 'die' implementations of sequence protocol should only be in
X	 sequence classes.
X	-class->can method -- test if class responds to given message
X		-also need to do something about argument counts.
X	-need to figure out what to do with negative indexes: handy but
X	 difficult to implement.  Either get rid of it or make all classes
X	 (including Interval) do it.
X		-maybe put 'normalizeIndex' in Object, then move to the
X	     Sequence trait when we have traits.
X			-ended up adding private method _sanitizeIndex
X	-prefix - with one argument must be tolerated by the compiler.
X	-exceptions
X	-hashes keyed on strings, symbols or numbers
X		-we can do other types later
        

	-replace all uses of 'function' with 'procedure'
		-also rename class 'Function' to class 'Procedure'
	-_::say and _::puts should tolerate Perl arguments.
	-get rid of/privatize 'shallowCopy'.
	-reorganize directory structure
		-notes and docs to separate subdirs
	-docs:
		-brochure
		-language reference
		

	-there should be some way to query a MethodCall to see if it's a
	 :doesNotUnderstand call.
	-_class_ext should be in '_::'
	-need to alias macros.
	-maybe make the comparisons other than <= into functions.
	-need to either 1) abandon negative indexes or 2) put the fixup
	 code in a common place (e.g. @)
	-should autosub args be capitalized?
	-maybe make Symbol a subclass of String
	-deepCopy
	-split Lang into Lang (builtin stuff) and Core (standalone Deck stuff)
	-boolean xor
	- static variables
	- integers
	- subify builtin
	- rewrite compiler
		- make the context a PerlObj in itself and pass it to
		  var/const/sub/set.
		-create and export Perl code
	- tuple assignment
			a,b,c = [foo]
			a,b,c = :[1 2 3]
			a, = :[1]
		-also, comma as list constructor?
			a, b, c = d, e, f = g, h, i
	-list slice
		-adding a slice fn.
		-should add the ability to '@'
	-object printstr/storestr
	-traits
	-hash/set/bag classes
	-mprocs should be able to select the argument name(s) of their
	 blocks.  (e.g. foreach)
	-quote should be a macro that expands into a function, just like
	 everything else.
	-can we make '-x' syntactic sugar for '[- x]'?
	-use Perl consts for the hidden (starts with space) special fields
     in Context and GlobalContext
	- merge symbol class-level qualified checks with namespace-level
	  checks.
	-functions (and subs and methods) should have an optional 'final'
	 block that gets called when the function returns, regardless of
	 how.
	-file I/O
	-should 'for/foreach' also define 'index' as a const?
	-interpolated strings should allow for "$foo.bar".
	-if macro should allow multiple 'elseif' clauses