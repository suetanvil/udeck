Getting docstrings...
Sorting keys...
Getting strings...
Selecting procedures...
=head1 Classes


=over


=item B<ByteArray (Stringlike)>  B<-- Built-in>

A C<ByteArray> is a sequence of 8-bit bytes. Any sequence of bytes is allowed.

C<ByteArray> implements the sequence protocol but will fail if you attempt to store a value in it that is not an integer between 0 and 255.

=item B<Class (Object)>  B<-- Built-in>

All classes (i.e. types) in Deck are themselves objects and those objects are instances of type C<Class>. This includes C<Class> itself.

C<Class> serves two purposes: to provide information about the class and to create new instances via its C<new> method.

=item B<List (Object)>  B<-- Built-in>

C<List> is the fundamental Deck list type. Unlike most Lispish languages, Deck does not present its lists as linked lists of cells. Instead, a Deck C<List> is an array (i.e. a "vector") of object references whose individual items can be accessed with the C<at> and C<atPut> methods (usually hidden by the C<@> operator). The indexes start at zero and increase to the number of items minus one.

This is different from most Lispish languages, where a list is implemented as a linked list of pairs of references (CONS cells).

C<List> implements the sequence protocol: C<at>, C<atput>, C<size>, C<maker> C<isIndexable> returns true.

=item B<Nil (Object)>  B<-- Built-in>

C<Nil> is the type of the object representing uninitialized variables. There is only one instance, the global constant C<nil>. Unset variables are initialized to nil, as are empty lists.

=item B<Number (Object)>  B<-- Built-in>

C<Number> is the class of all (built-in) number types in Deck. Instances are floating-point values.

=item B<Object (none)>  B<-- Built-in>

C<Object> is the root class. All other classes in Deck are derived from Object.

C<Object> is a pure abstract base class. It cannot be instantiated.

=item B<String (Stringlike)>  B<-- Built-in>

C<String> instances contain human-readable text which can be printed to the console or stored in a file. The class implements the sequence protocol but the objects stored or retrieved from a C<String> must themselves be strings of length 1. 

Unlike many other languages, Deck does not have a character type. Instead, strings are encoded in some manner and it is best not to make assumptions about the details. In particular, you should B<never> use a C<String> to hold arbitrary binary data as this will break when Deck switches to using UTF8. Use C<ByteArray> for that.

=item B<Stringlike (Object)>  B<-- Built-in>

This is the abstract base class for several classes representing various sequences of binary or specially-encoded data. It should not be used in any way.

=item B<Struct (Object)>  B<-- Built-in>

C<Struct> is the base class for all traditional classes. A traditional class is a class whose data is stored in named fields.

This is an abstract base class and cannot be instantiated. All subclasses should implement the method C<init> to initialize the fields when an instance is created.

C<Struct> subclasses are typically instantiated using the C<new> method or procedure.

=item B<Symbol (Stringlike)>  B<-- Built-in>

Symbols are mostly used to represent names in expressions. They are similar to strings in that they contain human-readable text. However, there are some notable differences:

=over

=item 1.

Symbols are immutable. C<atPut> will fail on one.

=item 2.

Symbols are unique. There is only ever one symbol with a particular value.

=back

C<Symbol> implements the sequence protocol but as mentioned above, the C<atPut> method will fail.

C<Symbols> can be converted to and from strings via the C<intern> and C<unintern> functions. Symbol constants are tokens beginning with the C<:> character, e.g. ":foo".

=back

