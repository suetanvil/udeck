
# This utility prints out the docstrings of the entire Deck systems.
# This is not good code.

use IO

# These are written in Perl for speed and to get at the Perl regexp
# system.  (To do: add Regexp interface.)

perlproc trimSpc {ts_s} '''
    LL::Main::fail ("trimSpc called with undefined value.")
        unless defined ($ts_s);

    my @paragraphs = split(/\n\n+/, $ts_s);

    for my $par (@paragraphs) {
        $par =~ s/\A\s*//gmx;   
        $par =~ s/\s*\z//gmx;
        $par =~ s/\s+/ /gmx;
    }

    my $result = join("\n\n", @paragraphs);
    return $result;
'''

perlproc podClean {s} '''
    my $r = {'<' => 'lt', '>' => 'gt'};
    $s =~ s{([<>])}{"E<".$r->{$1}.">"}eg;

    return $s;
'''


proc isProcOrMProc {doc} {
    "Test if C<doc> is a proc or mproc."

    (doc@0 == :proc && ([slice (doc@1) 0 3] != '__::')) && [return true]
    (doc@0 == :mproc) && [return true]
    return false
}

proc printFunctions {mproc pkg} {
    var filter = :proc
    var heading = "Procedures"
    var procType = "proc"

    if (mproc) {
        filter = :mproc
        heading = "MProcs"
        procType = "mproc"
    }

    var keys = [_::docstring_keys filter pkg]
    (keys.size > 0) || [return]

    puts "=head3 $heading\n"
    puts "=over\n\n"

    for key in keys {
        var doc = [_::docstring_get key]

        var ftag = (doc@0)
        var fname = (doc@1)
        var fbuiltin = (doc@2)
        var fnargs = (doc@3)
        var fdoc = [trimSpc (doc@4)]

        var biText = ""
        fbuiltin && (biText = " B<(Built-in)>")

        if (ftag != :mproc) {
            fnargs = "{$fnargs}"
        }

        puts "=item B<$procType $fname $fnargs>$biText\n"

        puts fdoc "\n"
    }

    puts "\n\n=back\n"
}


proc printMacros {pkg} {
    var keys = [_::docstring_keys :macro pkg]
    (keys.size > 0) || [return]

    puts "=head3 Macros\n"
    puts "=over\n\n"

    for key in keys {
        var doc = [_::docstring_get key]

        var ftag = (doc@0)
        var fname = [podClean (doc@1)]
        var fbuiltin = (doc@2)
        var fnargs = (doc@3)
        var fdoc = [trimSpc (doc@4)]

        var biText = ""
        fbuiltin && (biText = " B<(Built-in)>")

        puts "=item B<macro $fname {$fnargs}>$biText\n"

        puts fdoc "\n"
    }

    puts "\n\n=back\n"
}




proc printMethodDoc {doc} {
    var builtin = (doc@2)
    var methodName = (doc@4)
    var args = (doc@5)
    var fdoc = [trimSpc (doc@6)]
    
    var biText = ""
    builtin && (biText = " B<(Built-in)>")

    puts "=item B<method $methodName {$args}>$biText\n"
    puts fdoc "\n"
}



proc uniq {aSeq} {
    var result = [aSeq.maker aSeq.size]

    var index = 0
    var prev = nil
    for elem in aSeq {
        if (elem != prev) {
            result@index = elem
            prev = elem
            index = index + 1
        }
    }

    return [slice result 0 (index - 1)]
}

perlproc _attribName{s} '''
  return "" unless $s;
  return "" unless scalar ($s =~ s/_[gs]et$//);
  return $s;
'''

proc printAttribDoc {doc} {
    var builtin = (doc@2)
    var access = [unintern (doc@4)]
    var attribName = (doc@5)
    var docstr = [trimSpc (doc@6)]
    
    var biText = ""
    builtin && (biText = " B<(Built-in)>")

    puts "=item B<$access $attribName>$biText\n"
    puts docstr "\n"
}

proc printAttributes {name} {
    var cl = [lookup [intern name]]

    var attributes = [map {_attribName a} cl.methods]
    attributes = [reduce {value a} attributes]
    attributes = [sort cmp attributes]
    attributes = [uniq attributes]

    if (attributes.size == 0) {
        return
    }

    puts "I<Attributes>\n"
    puts "=over\n"

    for attr in attributes {
        var doc = [_::docstring_get "$name.$attr"]
        doc && [printAttribDoc doc]
    }

    puts "=back\n"
}


proc printMethods {name} {
    var cl = [lookup [intern name]]
    var selectors = [sort cmp cl.selectors]

    if (selectors.size == 0) {
        return
    }

    puts "I<Methods>\n"
    puts "=over\n"

    foreach sel in selectors {
        var doc = [_::docstring_get "$name->$sel"]
        if (doc) {
            printMethodDoc doc
        }
    }

    puts "=back\n"
}


proc printClasses {pkg} {
    var classNames = [_::docstring_keys :class pkg]
    (classNames.size > 0) || [return]

    puts "=head3 Classes\n\n"
    puts "=over\n\n"

    for classNm in classNames {
        var doc = [_::docstring_get classNm]

        var name = doc@1
        var builtin = doc@2
        var docstring = [trimSpc (doc@3)]

        var biText = ""
        builtin && (biText = " B<-- Built-in>")

        var cl = [lookup [intern name]]

        var sc = 'none'

        (cl == Object) || (sc = cl.superclass.name)
        sc = "($sc)"

        puts "=item B<$name $sc> $biText\n"

        puts docstring "\n"
        
        printAttributes name

        printMethods name

    }

    puts "=back\n"
}

proc printPackageHeader {pkg} {

    var pkgBase = [slice pkg 0 (pkg.last - 2)]
    puts "=head2 Package $pkgBase\n"

    var desc = [_::docstring_get pkg]@2
    puts desc
    puts "\n"
}


proc printPackage {pkg} {
    printPackageHeader pkg
    printFunctions true pkg
    printFunctions false pkg
    printMacros pkg
    printClasses pkg
}


# Lang needs to go first
var packages = [_::docstring_keys :package nil]
packages = [reduce { value (a != [intern "Lang::"]) } packages]
packages = [concat [list [intern "Lang::"]] packages]

for pkg in packages {
    printPackage pkg
}

